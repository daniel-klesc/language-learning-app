<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Language Learning App - Smart Vocabulary System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 100%;
            padding: 30px;
            position: relative;
        }

        /* Settings Icon */
        .settings-icon {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.3s;
            z-index: 100;
        }

        .settings-icon:hover {
            opacity: 1;
        }

        /* Settings Menu */
        .settings-menu {
            position: fixed;
            top: 0;
            right: -300px;
            width: 280px;
            height: 100vh;
            background: white;
            box-shadow: -5px 0 20px rgba(0,0,0,0.2);
            transition: right 0.3s ease;
            z-index: 2000;
            display: flex;
            flex-direction: column;
        }

        .settings-menu.open {
            right: 0;
        }

        .settings-header {
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: between;
            align-items: center;
        }

        .settings-close {
            margin-left: auto;
            cursor: pointer;
            font-size: 24px;
        }

        .settings-item {
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .settings-item:hover {
            background: #f8f9fa;
        }

        .settings-item-icon {
            font-size: 20px;
        }

        /* Overlay for settings */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1999;
            display: none;
        }

        .settings-overlay.open {
            display: block;
        }

        /* Study screen specific container for better mobile experience */
        .container.study-mode {
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 40px);
            max-height: 700px;
            overflow-y: auto;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            padding-right: 30px; /* Make space for settings icon */
        }

        h1 {
            color: #333;
            font-size: 24px;
            margin-bottom: 10px;
        }

        .time-estimate {
            color: #666;
            font-size: 14px;
            margin-bottom: 20px;
            text-align: center;
        }

        /* Skill Level Selector */
        .skill-selector {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .skill-selector-title {
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .skill-levels {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .skill-level-btn {
            padding: 10px 5px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-size: 12px;
        }

        .skill-level-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .skill-level-btn .emoji {
            font-size: 20px;
            display: block;
            margin-bottom: 4px;
        }

        /* Skill Pills in Session */
        .skill-pills {
            position: absolute;
            top: 8px;
            left: 15px;
            display: flex;
            gap: 4px;
        }

        .skill-pill {
            width: 24px;
            height: 24px;
            border-radius: 12px;
            background: rgba(255,255,255,0.3);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            user-select: none;
        }

        .skill-pill.active {
            background: white;
            color: #28a745;
            transform: scale(1.1);
        }

        /* Long-press menu */
        .skill-switch-menu {
            position: fixed;
            background: white;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            padding: 8px 0;
            z-index: 3000;
            min-width: 120px;
        }

        .skill-switch-option {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .skill-switch-option:hover {
            background: #f0f0f0;
        }

        .skill-switch-option.current {
            background: #e3f2fd;
            font-weight: bold;
        }

        .daily-goal {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .goal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .goal-title {
            font-size: 16px;
            opacity: 0.9;
        }

        .goal-numbers {
            font-size: 24px;
            font-weight: bold;
        }

        .goal-progress {
            background: rgba(255,255,255,0.3);
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .goal-progress-fill {
            background: white;
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .goal-details {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            opacity: 0.9;
        }

        /* Session progress card */
        .session-progress-card {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            position: relative;
            width: 100%;
        }

        .session-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            margin-top: 20px;
        }

        .session-progress-title {
            font-size: 14px;
            opacity: 0.9;
        }

        .session-progress-numbers {
            font-size: 20px;
            font-weight: bold;
            margin-right: 50px;
        }

        .session-progress-bar {
            background: rgba(255,255,255,0.3);
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .session-progress-fill {
            background: white;
            height: 100%;
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .session-progress-details {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            opacity: 0.9;
        }

        /* Beautiful pause button */
        .pause-button {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 32px;
            height: 32px;
            background: rgba(255,255,255,0.25);
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .pause-button:hover {
            background: rgba(255,255,255,0.35);
            transform: scale(1.1);
        }

        .pause-icon {
            width: 16px;
            height: 16px;
            position: relative;
        }

        .pause-icon::before,
        .pause-icon::after {
            content: '';
            position: absolute;
            width: 4px;
            height: 16px;
            background: white;
            border-radius: 1px;
        }

        .pause-icon::before {
            left: 3px;
        }

        .pause-icon::after {
            right: 3px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat {
            text-align: center;
            padding: 15px 10px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }

        .language-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .language-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .language-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .session-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .session-btn {
            padding: 20px;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .session-btn:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        .session-btn .words {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .session-btn .time {
            font-size: 14px;
            color: #666;
        }

        .session-btn .badge {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            margin-top: 5px;
        }

        /* Multiple Choice Layout */
        .choice-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 15px;
            width: 100%;
        }

        .choice-btn {
            padding: 12px 10px;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            min-height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .choice-btn:hover:not(:disabled) {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        .choice-btn.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .choice-btn.correct {
            border-color: #28a745;
            background: #d4edda;
            animation: correctPulse 0.5s;
        }

        .choice-btn.incorrect {
            border-color: #dc3545;
            background: #f8d7da;
            animation: shake 0.5s;
        }

        .choice-btn.dimmed {
            opacity: 0.5;
        }

        @keyframes correctPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .choice-text {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            display: block;
            margin-bottom: 2px;
        }

        .choice-romanization {
            font-size: 12px;
            color: #666;
        }
        
        /* Development Console Styles */
        .dev-console {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 400px;
            max-height: 300px;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 10px;
            border-radius: 8px;
            overflow-y: auto;
            z-index: 9999;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        
        .dev-console-header {
            color: #ffff00;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }
        
        .dev-log {
            margin: 2px 0;
            padding: 2px;
        }
        
        .dev-log.error {
            color: #ff6b6b;
        }
        
        .dev-log.success {
            color: #51cf66;
        }
        
        .dev-log.info {
            color: #339af0;
        }
        
        .dev-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 5px 10px;
            background: #333;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            z-index: 9998;
        }

        .continue-session {
            width: 100%;
            padding: 15px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.3s;
        }

        .continue-session:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
        }

        /* Improved card design for study mode */
        .card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px 20px;
            margin-bottom: 15px;
            text-align: center;
            flex-shrink: 0;
            min-height: 120px;
            width: 100%;
        }

        .word {
            font-size: 36px;
            font-weight: bold;
            color: #333;
            margin-bottom: 12px;
        }

        .romanization {
            font-size: 20px;
            color: #666;
            margin-bottom: 15px;
        }

        /* Category badge */
        .category {
            display: inline-block;
            padding: 6px 12px;
            background: #e9ecef;
            border-radius: 6px;
            font-size: 12px;
            color: #666;
            margin-bottom: 15px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 10px;
            transition: border-color 0.3s;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
        }

        /* Single button design for study mode */
        .study-button {
            width: 100% !important;
            padding: 14px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            background: #667eea;
            color: white;
            margin-top: auto;
            margin-bottom: 10px;
            display: block !important;
            box-sizing: border-box;
        }

        .study-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .study-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .study-button.next {
            background: #28a745;
        }

        .buttons {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 15px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .feedback {
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            width: 100%;
        }

        .feedback.correct {
            background: #d4edda;
            color: #155724;
        }

        .feedback.incorrect {
            background: #f8d7da;
            color: #721c24;
        }

        .feedback.partial {
            background: #fff3cd;
            color: #856404;
        }

        .feedback .correct-spelling {
            font-size: 14px;
            margin-top: 8px;
            font-weight: normal;
        }

        .feedback .user-answer {
            font-size: 13px;
            margin-top: 5px;
            font-weight: normal;
            opacity: 0.9;
        }

        .hidden {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
            position: absolute !important;
            left: -9999px !important;
        }

        .no-cards {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .achievement {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 20px;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .achievement-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .achievement-desc {
            font-size: 14px;
            opacity: 0.95;
        }

        .history {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .history-title {
            font-size: 14px;
            font-weight: bold;
            color: #666;
            margin-bottom: 10px;
        }

        .history-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
            font-size: 13px;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        /* Loading indicator */
        .loading-indicator {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Mobile optimizations for study mode */
        /* Vocabulary Manager Styles */
        .vocab-manager {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 3000;
            display: none; /* Changed from flex to none by default */
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .vocab-manager:not(.hidden) {
            display: flex; /* Show when not hidden */
        }

        .vocab-manager-content {
            background: white;
            border-radius: 20px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .vocab-manager-header {
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 20px 20px 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .vocab-manager-header h2 {
            margin: 0;
            font-size: 20px;
            flex-grow: 1;
            text-align: center;
        }

        .vocab-back-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .vocab-close {
            cursor: pointer;
            font-size: 28px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .vocab-manager-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .vocab-upload-section {
            margin-bottom: 20px;
        }

        .upload-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 20px;
            border-bottom: 2px solid #dee2e6;
        }

        .upload-tab {
            flex: 1;
            padding: 10px 15px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            transition: all 0.3s;
        }

        .upload-tab:hover {
            background: #f8f9fa;
        }

        .upload-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .upload-tab-content {
            display: none;
        }

        .github-input-section {
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .github-input-section label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        .github-input-section input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .github-input-section input:focus {
            outline: none;
            border-color: #667eea;
        }

        .github-hint {
            color: #666;
            font-size: 13px;
            margin-bottom: 15px;
        }

        .github-examples {
            background: white;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .github-examples small {
            color: #666;
            font-weight: 600;
        }

        .github-examples ul {
            margin: 5px 0 0 20px;
            padding: 0;
        }

        .github-examples li {
            color: #999;
            font-size: 12px;
            margin: 3px 0;
            word-break: break-all;
        }

        .github-load-btn {
            width: 100%;
            padding: 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .github-load-btn:hover {
            background: #5a72d8;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .github-load-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .github-status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-size: 13px;
            display: none;
        }

        .github-status.loading {
            display: block;
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .github-status.success {
            display: block;
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .github-status.error {
            display: block;
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .upload-zone {
            border: 2px dashed #667eea;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s;
            background: #f8f9fa;
        }

        .upload-zone.dragover {
            background: #e8ebff;
            border-color: #764ba2;
        }

        .upload-zone svg {
            margin-bottom: 10px;
        }

        .upload-zone p {
            color: #666;
            margin: 10px 0;
        }

        .upload-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }

        .upload-btn:hover {
            transform: translateY(-2px);
        }

        .vocab-search {
            margin-bottom: 20px;
        }

        .vocab-search input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
        }

        .vocab-search input:focus {
            outline: none;
            border-color: #667eea;
        }

        .vocab-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .vocab-tab {
            flex: 1;
            padding: 10px;
            background: #f8f9fa;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
            min-width: 140px;
        }

        .vocab-tab.active {
            background: #667eea;
            color: white;
        }

        .vocab-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 10px;
            padding: 10px;
        }

        .vocab-category {
            margin-bottom: 20px;
        }

        .vocab-category-header {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .vocab-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s;
        }

        .vocab-item:hover {
            background: #f8f9fa;
        }

        .vocab-item-text {
            flex-grow: 1;
        }

        .vocab-word {
            font-weight: 600;
            color: #333;
        }

        .vocab-translation {
            color: #666;
            font-size: 14px;
        }

        .vocab-item-actions {
            display: flex;
            gap: 5px;
        }

        .vocab-difficulty {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            background: #e9ecef;
        }

        .vocab-difficulty.easy {
            background: #d4edda;
            color: #155724;
        }

        .vocab-difficulty.medium {
            background: #fff3cd;
            color: #856404;
        }

        .vocab-difficulty.hard {
            background: #f8d7da;
            color: #721c24;
        }

        .vocab-stats {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            text-align: center;
            color: #666;
        }

        /* Upload Preview Modal */
        .upload-preview-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 4000;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .upload-preview-modal:not(.hidden) {
            display: flex;
        }

        .upload-preview-content {
            background: white;
            border-radius: 15px;
            max-width: 700px;
            width: 100%;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
        }

        .upload-preview-header {
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px 15px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .upload-preview-header h3 {
            margin: 0;
            font-size: 18px;
        }

        .upload-preview-close {
            cursor: pointer;
            font-size: 24px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .upload-preview-info {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }

        .upload-file-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .upload-summary {
            display: flex;
            gap: 20px;
        }

        .summary-item {
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 13px;
            font-weight: 600;
        }

        .summary-item.new {
            background: #d4edda;
            color: #155724;
        }

        .summary-item.duplicate {
            background: #fff3cd;
            color: #856404;
        }

        .summary-item.total {
            background: #d1ecf1;
            color: #0c5460;
        }

        .upload-preview-categories {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
        }

        .category-filters-label {
            font-size: 13px;
            color: #666;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .category-filters-grid {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .category-filter-btn {
            padding: 8px 16px;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
            color: #495057;
        }

        .category-filter-btn:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.2);
        }

        .category-filter-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .upload-preview-controls {
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #dee2e6;
        }

        .sort-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sort-controls label {
            font-size: 13px;
            color: #666;
        }

        .sort-controls select {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 13px;
        }

        .select-controls {
            display: flex;
            gap: 8px;
        }

        .select-all-btn,
        .select-none-btn {
            padding: 4px 12px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .select-all-btn:hover,
        .select-none-btn:hover {
            background: #f8f9fa;
            border-color: #667eea;
        }

        .preview-category-section {
            margin-bottom: 20px;
        }

        .preview-category-header {
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-category-count {
            font-weight: normal;
            color: #6c757d;
            font-size: 12px;
        }

        .upload-preview-filter-section {
            position: sticky;
            top: 0;
            background: white;
            z-index: 10;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .filter-toggle-bar {
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: background 0.3s;
        }

        .filter-toggle-bar:hover {
            background: linear-gradient(135deg, #5a72d8 0%, #6a4190 100%);
        }

        .filter-toggle-text {
            font-weight: 600;
            font-size: 14px;
        }

        .filter-toggle-icon {
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .filter-toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        .filter-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .filter-content.collapsed {
            max-height: 0;
            padding: 0 !important;
        }

        .upload-preview-filters {
            padding: 10px 20px;
            display: flex;
            gap: 10px;
            border-bottom: 1px solid #dee2e6;
        }

        .filter-btn {
            padding: 6px 12px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .filter-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .upload-preview-list {
            flex: 1;
            overflow-y: auto;
            padding: 15px 20px;
        }

        .preview-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s;
        }

        .preview-item.duplicate {
            background: #fff3cd;
        }

        .preview-item.new {
            background: #d4edda;
        }

        .preview-item.hidden {
            display: none;
        }

        .preview-checkbox {
            margin-right: 12px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .preview-item-content {
            flex: 1;
        }

        .preview-word {
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
        }

        .preview-translation {
            font-size: 13px;
            color: #666;
        }

        .preview-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 10px;
        }

        .preview-status.new {
            background: #28a745;
            color: white;
        }

        .preview-status.duplicate {
            background: #ffc107;
            color: #333;
        }

        .preview-duplicate-info {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
            padding: 5px;
            background: rgba(255,255,255,0.5);
            border-radius: 4px;
        }

        .upload-preview-actions {
            padding: 15px 20px;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
            border-radius: 0 0 15px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .duplicate-strategy {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .duplicate-strategy label {
            font-size: 14px;
            color: #666;
        }

        .duplicate-strategy select {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
        }

        .action-buttons button {
            padding: 8px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .action-buttons button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        @media (max-width: 480px) {
            .vocab-manager-content {
                max-width: 100%;
                max-height: 100%;
                height: 100%;
                border-radius: 0;
            }

            .vocab-manager-header {
                border-radius: 0;
            }

            .vocab-tabs {
                flex-direction: column;
            }

            .vocab-tab {
                width: 100%;
            }
        }
            .container {
                width: 100%;
                max-width: 100%;
            }

            .container.study-mode {
                padding: 12px;
                height: 100vh;
                max-height: 100vh;
                border-radius: 0;
                margin: 0;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: white;
                z-index: 1000;
            }

            body {
                padding: 0;
                min-height: 100vh;
                overflow-x: hidden;
            }

            .hidden {
                display: none !important;
                visibility: hidden !important;
                opacity: 0 !important;
                pointer-events: none !important;
                position: absolute !important;
                left: -9999px !important;
            }
            
            .container:not(.study-mode) {
                border-radius: 0;
                min-height: 100vh;
                padding: 20px 15px;
                box-shadow: none;
            }
            
            .session-progress-card {
                padding: 12px;
                margin-bottom: 12px;
            }
            
            .word {
                font-size: 28px;
            }
            
            .romanization {
                font-size: 16px;
            }
            
            .card {
                padding: 20px 15px;
                margin-bottom: 12px;
            }

            .choice-grid {
                grid-template-columns: 1fr 1fr;
                gap: 8px;
                margin-bottom: 12px;
            }

            .choice-btn {
                padding: 10px 8px;
                min-height: 55px;
            }

            .choice-text {
                font-size: 14px;
            }

            .choice-romanization {
                font-size: 11px;
            }

            .feedback {
                padding: 10px;
                margin-bottom: 12px;
                font-size: 13px;
            }

            .input-group {
                margin-bottom: 12px;
            }

            input {
                padding: 10px;
                font-size: 15px;
            }

            .study-button {
                padding: 12px;
                font-size: 15px;
                margin-bottom: 5px;
            }

            #study-screen {
                padding-bottom: 10px;
                width: 100%;
                height: 100%;
            }

            .session-progress-numbers {
                font-size: 18px;
                margin-right: 40px;
            }

            .pause-button {
                width: 28px;
                height: 28px;
                top: 10px;
                right: 10px;
            }

            .pause-icon {
                width: 14px;
                height: 14px;
            }

            .pause-icon::before,
            .pause-icon::after {
                width: 3px;
                height: 14px;
            }

            #study-screen {
                display: flex;
                flex-direction: column;
                height: 100%;
                min-height: 0;
            }

            .study-button {
                flex-shrink: 0;
            }
            
            #start-screen, #study-screen, #complete-screen {
                position: relative;
                width: 100%;
            }
            
            #start-screen:not(.hidden) {
                display: block;
            }
            
            #study-screen:not(.hidden) {
                display: flex;
            }
            
            #complete-screen:not(.hidden) {
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="container" id="main-container">
        <!-- Settings Icon -->
        <svg class="settings-icon" onclick="toggleSettings()" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
        </svg>

        <!-- Home Screen Content -->
        <div id="home-content">
            <div class="header">
                <h1>🎯 Smart Language Learning</h1>
                <div class="time-estimate" id="time-estimate">Daily goal: ~15 minutes</div>
            </div>

            <!-- Skill Level Selector -->
            <div class="skill-selector">
                <div class="skill-selector-title">Default Skill Level</div>
                <div class="skill-levels">
                    <button class="skill-level-btn" data-level="1" onclick="setDefaultSkillLevel(1)">
                        <span class="emoji">🌱</span>
                        Beginner
                    </button>
                    <button class="skill-level-btn" data-level="2" onclick="setDefaultSkillLevel(2)">
                        <span class="emoji">📘</span>
                        Intermediate
                    </button>
                    <button class="skill-level-btn" data-level="3" onclick="setDefaultSkillLevel(3)">
                        <span class="emoji">🎯</span>
                        Advanced
                    </button>
                    <button class="skill-level-btn active" data-level="0" onclick="setDefaultSkillLevel(0)">
                        <span class="emoji">🤖</span>
                        Auto
                    </button>
                </div>
            </div>

            <!-- Daily Goal Card -->
            <div class="daily-goal">
                <div class="goal-header">
                    <span class="goal-title">Today's Goal</span>
                    <span class="goal-numbers" id="goal-progress">0/8</span>
                </div>
                <div class="goal-progress">
                    <div class="goal-progress-fill" id="goal-bar" style="width: 0%"></div>
                </div>
                <div class="goal-details">
                    <span id="words-new">New: 0/3</span>
                    <span id="words-review">Review: 0/5</span>
                    <span id="time-spent">Time: 0 min</span>
                </div>
            </div>

            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="streak">0</div>
                    <div class="stat-label">Day Streak</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="total-learned">0</div>
                    <div class="stat-label">Words Mastered</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="accuracy">0%</div>
                    <div class="stat-label">Accuracy</div>
                </div>
            </div>

            <div class="language-selector">
                <button class="language-btn active" data-pair="cs-vi">🇨🇿→🇻🇳</button>
                <button class="language-btn" data-pair="vi-zh">🇻🇳→🇨🇳</button>
                <button class="language-btn" data-pair="vi-en">🇻🇳→🇬🇧</button>
            </div>

            <!-- Start Screen with Session Options -->
            <div id="start-screen">
                <div id="continue-session-btn" class="hidden">
                    <button class="continue-session" onclick="continueSession()">
                        📚 Continue Session (<span id="remaining-words">0</span> words left)
                    </button>
                </div>

                <div class="session-options">
                    <div class="session-btn" onclick="startSession(1)">
                        <div class="words">1</div>
                        <div class="time">~1 min</div>
                        <span class="badge">Quick</span>
                    </div>
                    <div class="session-btn recommended" onclick="startSession(3)">
                        <div class="words">3</div>
                        <div class="time">~3 min</div>
                        <span class="badge">Recommended</span>
                    </div>
                    <div class="session-btn" onclick="startSession(5)">
                        <div class="words">5</div>
                        <div class="time">~5 min</div>
                    </div>
                    <div class="session-btn" onclick="startSession(0)">
                        <div class="words">All</div>
                        <div class="time" id="all-time">~8 min</div>
                    </div>
                </div>

                <div class="history">
                    <div class="history-title">Today's Sessions</div>
                    <div id="session-history"></div>
                </div>
            </div>
        </div>

        <!-- Study Screen - Completely separate -->
        <div id="study-screen" class="hidden" style="display: none;">
            <div style="display: flex; flex-direction: column; width: 100%;">
                <!-- Session Progress Card with Skill Pills -->
                <div class="session-progress-card">
                    <div class="skill-pills">
                        <span class="skill-pill" data-level="1" id="pill-beginner">B</span>
                        <span class="skill-pill" data-level="2" id="pill-intermediate">I</span>
                        <span class="skill-pill" data-level="3" id="pill-advanced">A</span>
                    </div>
                    <div class="pause-button" onclick="pauseSession()" title="Pause">
                        <div class="pause-icon"></div>
                    </div>
                    <div class="session-progress-header">
                        <span class="session-progress-title">Session Progress</span>
                        <span class="session-progress-numbers">
                            <span id="current-word-num">1</span>/<span id="total-words">3</span>
                        </span>
                    </div>
                    <div class="session-progress-bar">
                        <div class="session-progress-fill" id="session-bar" style="width: 0%"></div>
                    </div>
                    <div class="session-progress-details">
                        <span id="session-correct">Correct: 0</span>
                        <span id="session-accuracy">Accuracy: 0%</span>
                    </div>
                </div>

                <!-- Card Display -->
                <div class="card">
                    <div class="category" id="category"></div>
                    <div class="word" id="word"></div>
                    <div class="romanization" id="romanization" class="hidden"></div>
                </div>

                <div class="feedback hidden" id="feedback"></div>

                <!-- Multiple Choice Grid (for beginner) -->
                <div class="choice-grid hidden" id="choice-grid">
                    <!-- Choices will be generated dynamically -->
                </div>

                <!-- Text Input (for intermediate/advanced) -->
                <div class="input-group hidden" id="input-group">
                    <input type="text" id="answer" placeholder="Type the translation..." autocomplete="off">
                </div>

                <!-- Action Button -->
                <button class="study-button" id="action-button" onclick="handleButtonClick()">Check Answer</button>
            </div>
        </div>

        <!-- Complete Screen -->
        <div id="complete-screen" class="hidden" style="display: none;">
            <div id="achievement" class="achievement hidden">
                <div class="achievement-title">🎉 Goal Achieved!</div>
                <div class="achievement-desc">You've completed your daily goal!</div>
            </div>
            
            <div class="no-cards">
                <h2>Session Complete!</h2>
                <p style="margin: 20px 0;">
                    Words practiced: <strong id="session-words">0</strong><br>
                    Accuracy: <strong id="session-accuracy-final">0%</strong><br>
                    Time: <strong id="session-time">0</strong> minutes
                </p>
                <button class="btn-primary" onclick="backToStart()">Continue Learning</button>
                <button class="btn-secondary" onclick="finishForToday()" style="margin-top: 10px;">Finish for Now</button>
            </div>
        </div>
    </div>

    <!-- Settings Menu -->
    <div class="settings-menu" id="settings-menu">
        <div class="settings-header">
            <span style="font-size: 18px; font-weight: bold;">Settings</span>
            <span class="settings-close" onclick="toggleSettings()">×</span>
        </div>
        <div class="settings-item" onclick="window.openVocabManager ? openVocabManager() : alert('Function not loaded')">
            <span class="settings-item-icon">📚</span>
            <span>Vocabulary Manager</span>
        </div>
        <div class="settings-item" onclick="refreshVocabulary()">
            <span class="settings-item-icon">🔄</span>
            <span>Refresh Vocabulary</span>
        </div>
        <div class="settings-item" onclick="showStatistics()">
            <span class="settings-item-icon">📊</span>
            <span>Statistics</span>
        </div>
        <div class="settings-item" onclick="exportProgress()">
            <span class="settings-item-icon">💾</span>
            <span>Export Progress</span>
        </div>
        <div class="settings-item" onclick="resetAllData()">
            <span class="settings-item-icon">🗑️</span>
            <span>Reset All Data</span>
        </div>
    </div>
    
    <!-- Settings Overlay -->
    <div class="settings-overlay" id="settings-overlay" onclick="toggleSettings()"></div>

    <!-- Vocabulary Manager Modal -->
    <div class="vocab-manager hidden" id="vocab-manager">
        <div class="vocab-manager-content">
            <div class="vocab-manager-header">
                <button class="vocab-back-btn" onclick="closeVocabManager()">←</button>
                <h2>Vocabulary Manager</h2>
                <span class="vocab-close" onclick="closeVocabManager()">×</span>
            </div>
            
            <div class="vocab-manager-body">
                <!-- Upload Section -->
                <div class="vocab-upload-section">
                    <div class="upload-tabs">
                        <button class="upload-tab active" onclick="switchUploadTab('local')">Upload Files</button>
                        <button class="upload-tab" onclick="switchUploadTab('github')">Load from GitHub</button>
                    </div>
                    
                    <div class="upload-tab-content" id="local-upload" style="display: block;">
                        <div class="upload-zone" id="upload-zone" ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#667eea" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="17 8 12 3 7 8"></polyline>
                                <line x1="12" y1="3" x2="12" y2="15"></line>
                            </svg>
                            <p>Drag & drop JSON files here or</p>
                            <button class="upload-btn" onclick="document.getElementById('file-input').click()">Choose Files</button>
                            <input type="file" id="file-input" multiple accept=".json" style="display: none;" onchange="handleFileSelect(event)">
                        </div>
                    </div>
                    
                    <div class="upload-tab-content" id="github-upload" style="display: none;">
                        <div class="github-input-section">
                            <label for="github-url">GitHub Repository URL:</label>
                            <input type="text" id="github-url" placeholder="https://github.com/username/repo/tree/main/vocabulary">
                            <p class="github-hint">Enter the URL to a public GitHub folder containing JSON vocabulary files</p>
                            <div class="github-examples">
                                <small>Examples:</small>
                                <ul>
                                    <li>https://github.com/username/repo/tree/main/vocabulary</li>
                                    <li>https://github.com/username/language-learning/tree/main/cs-vi</li>
                                </ul>
                            </div>
                            <button class="github-load-btn" onclick="loadFromGitHub()">Load Vocabulary</button>
                            <div id="github-status" class="github-status"></div>
                        </div>
                    </div>
                </div>

                <!-- Search Bar -->
                <div class="vocab-search">
                    <input type="text" id="vocab-search-input" placeholder="Search vocabulary..." oninput="searchVocabulary(this.value)">
                </div>

                <!-- Language Tabs -->
                <div class="vocab-tabs">
                    <button class="vocab-tab active" data-lang="cs-vi" onclick="switchVocabTab('cs-vi')">Czech→Vietnamese</button>
                    <button class="vocab-tab" data-lang="vi-zh" onclick="switchVocabTab('vi-zh')">Vietnamese→Chinese</button>
                    <button class="vocab-tab" data-lang="vi-en" onclick="switchVocabTab('vi-en')">Vietnamese→English</button>
                </div>

                <!-- Vocabulary List -->
                <div class="vocab-list" id="vocab-list">
                    <!-- Will be populated dynamically -->
                </div>

                <!-- Stats Footer -->
                <div class="vocab-stats">
                    <span id="vocab-stats-text">Total: 0 words</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Upload Preview Modal -->
    <div class="upload-preview-modal hidden" id="upload-preview-modal">
        <div class="upload-preview-content">
            <div class="upload-preview-header">
                <h3>Review Import</h3>
                <span class="upload-preview-close" onclick="cancelUploadPreview()">×</span>
            </div>
            
            <div class="upload-preview-info">
                <div class="upload-file-name" id="upload-file-name">File: example.json</div>
                <div class="upload-summary" id="upload-summary">
                    <span class="summary-item new">New: 0</span>
                    <span class="summary-item duplicate">Duplicates: 0</span>
                    <span class="summary-item total">Total: 0</span>
                </div>
            </div>
            
            <div class="upload-preview-filter-section" id="filter-section">
                <div class="filter-toggle-bar" onclick="toggleFilterSection()">
                    <span class="filter-toggle-text">Filters & Sorting</span>
                    <span class="filter-toggle-icon" id="filter-toggle-icon">▼</span>
                </div>
                
                <div class="filter-content" id="filter-content">
                    <div class="upload-preview-filters">
                        <button class="filter-btn active" onclick="filterPreview('all')">All</button>
                        <button class="filter-btn" onclick="filterPreview('new')">New Only</button>
                        <button class="filter-btn" onclick="filterPreview('duplicate')">Duplicates Only</button>
                    </div>
                    
                    <div class="upload-preview-controls">
                        <div class="sort-controls">
                            <label>View:</label>
                            <select id="preview-view-mode" onchange="updatePreviewDisplay()">
                                <option value="category">By Category</option>
                                <option value="alphabetical">Alphabetical</option>
                            </select>
                            <label>Sort by:</label>
                            <select id="preview-sort-language" onchange="updatePreviewDisplay()">
                                <option value="source">Source Language</option>
                                <option value="target">Target Language</option>
                            </select>
                        </div>
                        <div class="select-controls">
                            <button class="select-all-btn" onclick="selectAllWords(true)">Select All</button>
                            <button class="select-none-btn" onclick="selectAllWords(false)">Select None</button>
                        </div>
                    </div>
                    
                    <div class="upload-preview-categories" id="upload-preview-categories">
                        <!-- Category filter buttons will be added here -->
                    </div>
                </div>
            </div>
            
            <div class="upload-preview-list" id="upload-preview-list">
                <!-- Will be populated with preview items -->
            </div>
            
            <div class="upload-preview-actions">
                <div class="duplicate-strategy">
                    <label>For duplicates:</label>
                    <select id="duplicate-strategy">
                        <option value="skip">Skip</option>
                        <option value="replace">Replace</option>
                        <option value="add">Add as alternate</option>
                    </select>
                </div>
                <div class="action-buttons">
                    <button class="btn-secondary" onclick="cancelUploadPreview()">Cancel</button>
                    <button class="btn-primary" onclick="confirmUpload()">Import Selected</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Skill Switch Menu (appears on long-press) -->
    <div class="skill-switch-menu hidden" id="skill-switch-menu">
        <div class="skill-switch-option" data-level="1" onclick="switchSkillLevel(1)">🌱 Beginner</div>
        <div class="skill-switch-option" data-level="2" onclick="switchSkillLevel(2)">📘 Intermediate</div>
        <div class="skill-switch-option" data-level="3" onclick="switchSkillLevel(3)">🎯 Advanced</div>
    </div>

    <!-- Development Console -->
    <button class="dev-toggle hidden" id="dev-toggle" onclick="toggleDevConsole()">Show Dev Console</button>
    <div class="dev-console hidden" id="dev-console">
        <div class="dev-console-header">🔧 Development Console</div>
        <div id="dev-logs"></div>
    </div>

    <script>
        // ============= DEVELOPMENT MODE TOGGLE =============
        const DEV_MODE = true;
        
        // Development console logging
        function devLog(message, type = 'info') {
            if (!DEV_MODE) return;
            
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] ${message}`);
            
            const logDiv = document.getElementById('dev-logs');
            if (logDiv) {
                const logEntry = document.createElement('div');
                logEntry.className = `dev-log ${type}`;
                logEntry.textContent = `[${timestamp}] ${message}`;
                logDiv.insertBefore(logEntry, logDiv.firstChild);
                
                // Keep only last 50 logs
                while (logDiv.children.length > 50) {
                    logDiv.removeChild(logDiv.lastChild);
                }
            }
        }
        
        function toggleDevConsole() {
            const console = document.getElementById('dev-console');
            const toggle = document.getElementById('dev-toggle');
            if (console.classList.contains('hidden')) {
                console.classList.remove('hidden');
                toggle.textContent = 'Hide Dev Console';
                showVocabularyStatus();
            } else {
                console.classList.add('hidden');
                toggle.textContent = 'Show Dev Console';
            }
        }
        
        function showVocabularyStatus() {
            if (!DEV_MODE) return;
            
            const data = loadProgress();
            const now = Date.now();
            const vocabSet = vocabularyData[currentLanguagePair] || [];
            
            devLog('=== VOCABULARY STATUS ===', 'success');
            devLog(`Current Language Pair: ${currentLanguagePair}`, 'info');
            devLog(`Total vocabulary loaded: ${vocabSet.length} words`, 'info');
            
            let newCount = 0, dueCount = 0, futureCount = 0;
            
            vocabSet.forEach(card => {
                const progress = data.progress?.[currentLanguagePair]?.[card.id];
                if (!progress) {
                    newCount++;
                    devLog(`ID ${card.id}: "${card.word}" - NEW (never seen)`, 'info');
                } else {
                    const daysUntilReview = Math.ceil((progress.nextReview - now) / 86400000);
                    const skillLevel = progress.skillLevel || 1;
                    const skillName = ['', 'Beginner', 'Intermediate', 'Advanced'][skillLevel];
                    
                    if (progress.nextReview <= now) {
                        dueCount++;
                        devLog(`ID ${card.id}: "${card.word}" - DUE NOW (Level ${progress.level}, Skill: ${skillName})`, 'success');
                    } else {
                        futureCount++;
                        devLog(`ID ${card.id}: "${card.word}" - Due in ${daysUntilReview} days (Level ${progress.level}, Skill: ${skillName})`, 'info');
                    }
                }
            });
            
            devLog(`Summary: ${newCount} new, ${dueCount} due, ${futureCount} future`, 'success');
            devLog(`Daily Progress: ${data.dailyProgress?.new || 0}/${dailyGoal.new} new, ${data.dailyProgress?.review || 0}/${dailyGoal.review} review`, 'info');
            devLog(`Default Skill Level: ${defaultSkillLevel === 0 ? 'Auto' : defaultSkillLevel}`, 'info');
        }
        
        // Initialize dev mode
        if (DEV_MODE) {
            window.addEventListener('load', () => {
                document.getElementById('dev-toggle').classList.remove('hidden');
                devLog('Development mode enabled', 'success');
                devLog('Set DEV_MODE = false for production', 'info');
            });
        }

        // ============= CONSTANTS & CONFIGURATION =============
        
        // Skill level constants
        const SKILL_LEVELS = {
            BEGINNER: 1,
            INTERMEDIATE: 2,
            ADVANCED: 3
        };

        const SKILL_NAMES = {
            1: 'Beginner',
            2: 'Intermediate', 
            3: 'Advanced'
        };

        // Spaced repetition configuration
        const BASE_INTERVALS = [1, 3, 7, 14, 30, 90]; // Days

        // Skill level multipliers for progression
        const SKILL_MULTIPLIERS = {
            1: 0.5,    // Beginner: 50% progression
            2: 0.75,   // Intermediate: 75% progression
            3: 1.0     // Advanced: 100% progression
        };

        // Promotion thresholds
        const PROMOTION_THRESHOLD = {
            streak: 3,      // Consecutive correct answers
            accuracy: 0.8   // 80% accuracy at level
        };

        // ============= VOCABULARY DATA =============
        // This will be replaced by external loading, but kept as fallback
        let vocabularyData = {};
        
        // Fallback vocabulary (embedded)
        const fallbackVocabulary = {
            'cs-vi': [
                // Greetings & Politeness
                { id: 1, word: 'ahoj', translation: 'xin chào', romanization: 'sin chào', category: 'greetings', difficulty: 1 },
                { id: 2, word: 'děkuji', translation: 'cảm ơn', romanization: 'cảm ơn', category: 'greetings', difficulty: 1 },
                { id: 41, word: 'prosím', translation: 'làm ơn', romanization: 'làm ơn', category: 'greetings', difficulty: 1 },
                { id: 42, word: 'promiňte', translation: 'xin lỗi', romanization: 'sin lỗi', category: 'greetings', difficulty: 1 },
                { id: 43, word: 'nashledanou', translation: 'tạm biệt', romanization: 'tạm biệt', category: 'greetings', difficulty: 1 },
                
                // Basics
                { id: 3, word: 'ano', translation: 'vâng', romanization: 'vâng', category: 'basics', difficulty: 1 },
                { id: 4, word: 'ne', translation: 'không', romanization: 'không', category: 'basics', difficulty: 1 },
                { id: 15, word: 'dům', translation: 'nhà', romanization: 'nhà', category: 'basics', difficulty: 1 },
                { id: 16, word: 'škola', translation: 'trường học', romanization: 'trường học', category: 'basics', difficulty: 2 },
                { id: 17, word: 'kniha', translation: 'sách', romanization: 'sách', category: 'basics', difficulty: 2 },
                { id: 20, word: 'práce', translation: 'công việc', romanization: 'công việc', category: 'basics', difficulty: 2 },
                
                // Numbers
                { id: 7, word: 'jeden', translation: 'một', romanization: 'một', category: 'numbers', difficulty: 1 },
                { id: 8, word: 'dva', translation: 'hai', romanization: 'hai', category: 'numbers', difficulty: 1 },
                { id: 9, word: 'tři', translation: 'ba', romanization: 'ba', category: 'numbers', difficulty: 1 },
                { id: 10, word: 'čtyři', translation: 'bốn', romanization: 'bốn', category: 'numbers', difficulty: 2 },
                { id: 11, word: 'pět', translation: 'năm', romanization: 'năm', category: 'numbers', difficulty: 2 },
                
                // Family
                { id: 12, word: 'rodina', translation: 'gia đình', romanization: 'gia đình', category: 'family', difficulty: 2 },
                { id: 13, word: 'matka', translation: 'mẹ', romanization: 'mẹ', category: 'family', difficulty: 1 },
                { id: 14, word: 'otec', translation: 'bố', romanization: 'bố', category: 'family', difficulty: 1 },
                
                // Food & Drink
                { id: 5, word: 'voda', translation: 'nước', romanization: 'nước', category: 'food', difficulty: 1 },
                { id: 6, word: 'chléb', translation: 'bánh mì', romanization: 'bánh mì', category: 'food', difficulty: 2 }
            ],
            'vi-zh': [
                { id: 21, word: 'xin chào', translation: '你好', romanization: 'nǐ hǎo', category: 'greetings', difficulty: 1 },
                { id: 22, word: 'cảm ơn', translation: '谢谢', romanization: 'xiè xie', category: 'greetings', difficulty: 1 },
                { id: 23, word: 'một', translation: '一', romanization: 'yī', category: 'numbers', difficulty: 1 },
                { id: 24, word: 'hai', translation: '二', romanization: 'èr', category: 'numbers', difficulty: 1 },
                { id: 25, word: 'ba', translation: '三', romanization: 'sān', category: 'numbers', difficulty: 1 },
                { id: 26, word: 'nước', translation: '水', romanization: 'shuǐ', category: 'food', difficulty: 1 },
                { id: 27, word: 'cơm', translation: '米饭', romanization: 'mǐ fàn', category: 'food', difficulty: 2 },
                { id: 28, word: 'gia đình', translation: '家庭', romanization: 'jiā tíng', category: 'family', difficulty: 2 },
                { id: 29, word: 'mẹ', translation: '妈妈', romanization: 'mā ma', category: 'family', difficulty: 1 },
                { id: 30, word: 'bố', translation: '爸爸', romanization: 'bà ba', category: 'family', difficulty: 1 }
            ],
            'vi-en': [
                { id: 31, word: 'xin chào', translation: 'hello', romanization: '', category: 'greetings', difficulty: 1 },
                { id: 32, word: 'cảm ơn', translation: 'thank you', romanization: '', category: 'greetings', difficulty: 1 },
                { id: 33, word: 'một', translation: 'one', romanization: '', category: 'numbers', difficulty: 1 },
                { id: 34, word: 'hai', translation: 'two', romanization: '', category: 'numbers', difficulty: 1 },
                { id: 35, word: 'ba', translation: 'three', romanization: '', category: 'numbers', difficulty: 1 },
                { id: 36, word: 'nước', translation: 'water', romanization: '', category: 'food', difficulty: 1 },
                { id: 37, word: 'bánh mì', translation: 'bread', romanization: '', category: 'food', difficulty: 1 },
                { id: 38, word: 'gia đình', translation: 'family', romanization: '', category: 'family', difficulty: 1 },
                { id: 39, word: 'nhà', translation: 'house', romanization: '', category: 'basics', difficulty: 1 },
                { id: 40, word: 'trường học', translation: 'school', romanization: '', category: 'basics', difficulty: 2 }
            ]
        };

        // ============= VOCABULARY LOADING SYSTEM =============
        async function loadVocabulary(languagePair, forceRefresh = false) {
            const cacheKey = `vocabularyCache_${languagePair}`;
            const cache = localStorage.getItem(cacheKey);
            const now = Date.now();
            
            // Check cache (24 hour expiry)
            if (!forceRefresh && cache) {
                const cached = JSON.parse(cache);
                if (cached.timestamp && (now - cached.timestamp) < 86400000) {
                    devLog(`Loading vocabulary from cache for ${languagePair}`, 'info');
                    return cached.words;
                }
            }
            
            // Try to load from external files
            try {
                devLog(`Fetching vocabulary files for ${languagePair}...`, 'info');
                const response = await fetch(`./vocabulary/${languagePair}/core.json`);
                
                if (response.ok) {
                    const data = await response.json();
                    const words = data.words || data;
                    
                    // Cache the loaded vocabulary
                    localStorage.setItem(cacheKey, JSON.stringify({
                        timestamp: now,
                        words: words
                    }));
                    
                    devLog(`Loaded ${words.length} words from external file for ${languagePair}`, 'success');
                    return words;
                }
            } catch (error) {
                devLog(`Failed to load external vocabulary for ${languagePair}: ${error.message}`, 'error');
            }
            
            // Fallback to embedded vocabulary
            devLog(`Using fallback vocabulary for ${languagePair}`, 'info');
            return fallbackVocabulary[languagePair] || [];
        }

        async function initializeVocabulary() {
            devLog('Initializing vocabulary system...', 'info');
            
            // Load vocabulary for all language pairs
            for (const pair of ['cs-vi', 'vi-zh', 'vi-en']) {
                vocabularyData[pair] = await loadVocabulary(pair);
            }
            
            devLog('Vocabulary initialization complete', 'success');
        }

        async function refreshVocabulary() {
            devLog('Refreshing all vocabulary...', 'info');
            
            // Show loading indicator
            const settingsMenu = document.getElementById('settings-menu');
            const originalContent = settingsMenu.innerHTML;
            
            // Clear cache and reload
            for (const pair of ['cs-vi', 'vi-zh', 'vi-en']) {
                vocabularyData[pair] = await loadVocabulary(pair, true);
            }
            
            devLog('Vocabulary refresh complete', 'success');
            alert('Vocabulary refreshed successfully!');
            toggleSettings();
        }

        // ============= VOCABULARY MANAGER FUNCTIONS =============
        let currentVocabTab = 'cs-vi';
        let userVocabulary = {}; // Store user-uploaded vocabulary
        let vocabularyFiles = {}; // Track loaded files
        let pendingUpload = null; // Store pending upload data
        let currentFilter = 'all'; // Track current filter
        let activeCategories = new Set(); // Track active category filters

        // Helper functions (need to be defined before they're used)
        function loadVocabManagerData() {
            // Load user vocabulary from localStorage
            const saved = localStorage.getItem('userVocabulary');
            if (saved) {
                userVocabulary = JSON.parse(saved);
            }
            
            // Load file tracking
            const files = localStorage.getItem('vocabularyFiles');
            if (files) {
                vocabularyFiles = JSON.parse(files);
            }
            
            displayVocabulary(currentVocabTab);
        }

        function displayVocabulary(lang) {
            const vocabList = document.getElementById('vocab-list');
            if (!vocabList) return;
            
            const vocab = vocabularyData[lang] || [];
            const userVocab = userVocabulary[lang] || [];
            const allVocab = [...vocab, ...userVocab];
            
            // Group by category
            const categories = {};
            allVocab.forEach(word => {
                if (!categories[word.category]) {
                    categories[word.category] = [];
                }
                categories[word.category].push(word);
            });
            
            // Build HTML
            let html = '';
            Object.keys(categories).sort().forEach(category => {
                html += `
                    <div class="vocab-category">
                        <div class="vocab-category-header">
                            <span>${category.charAt(0).toUpperCase() + category.slice(1)}</span>
                            <span>${categories[category].length} words</span>
                        </div>`;
                
                categories[category].forEach(word => {
                    const difficultyClass = word.difficulty === 1 ? 'easy' : 
                                          word.difficulty === 2 ? 'medium' : 'hard';
                    const difficultyText = word.difficulty === 1 ? 'Easy' : 
                                         word.difficulty === 2 ? 'Medium' : 'Hard';
                    
                    html += `
                        <div class="vocab-item" data-word="${(word.word || '').toLowerCase()}" data-translation="${(word.translation || '').toLowerCase()}">
                            <div class="vocab-item-text">
                                <div class="vocab-word">${word.word}</div>
                                <div class="vocab-translation">${word.translation} ${word.romanization ? `(${word.romanization})` : ''}</div>
                            </div>
                            <div class="vocab-item-actions">
                                <span class="vocab-difficulty ${difficultyClass}">${difficultyText}</span>
                            </div>
                        </div>`;
                });
                
                html += '</div>';
            });
            
            vocabList.innerHTML = html || '<p style="text-align: center; color: #999;">No vocabulary loaded</p>';
            
            // Update stats
            const statsElement = document.getElementById('vocab-stats-text');
            if (statsElement) {
                statsElement.textContent = `Total: ${allVocab.length} words across ${Object.keys(categories).length} categories`;
            }
        }

        function checkDuplicates(newWords, languagePair) {
            const existingVocab = [...(vocabularyData[languagePair] || []), ...(userVocabulary[languagePair] || [])];
            const results = [];
            
            newWords.forEach(newWord => {
                const duplicate = existingVocab.find(existing => 
                    existing.word.toLowerCase() === newWord.word.toLowerCase()
                );
                
                results.push({
                    ...newWord,
                    status: duplicate ? 'duplicate' : 'new',
                    existingWord: duplicate,
                    selected: true // Default to selected
                });
            });
            
            return results;
        }

        function showUploadPreview(file, data, languagePair) {
            console.log('showUploadPreview called', file.name, data, languagePair);
            devLog(`Showing preview for ${file.name}`, 'info');
            
            try {
                const words = data.words || [];
                const analyzedWords = checkDuplicates(words, languagePair);
                
                // Store pending upload data
                pendingUpload = {
                    file: file,
                    languagePair: languagePair,
                    words: analyzedWords,
                    metadata: data.metadata || {}
                };
                
                // Reset filters
                currentFilter = 'all';
                activeCategories.clear();
                
                // Update preview header
                const fileNameElement = document.getElementById('upload-file-name');
                if (fileNameElement) {
                    fileNameElement.textContent = `File: ${file.name}`;
                }
                
                // Count status
                const newCount = analyzedWords.filter(w => w.status === 'new').length;
                const duplicateCount = analyzedWords.filter(w => w.status === 'duplicate').length;
                
                const summaryElement = document.getElementById('upload-summary');
                if (summaryElement) {
                    summaryElement.innerHTML = `
                        <span class="summary-item new">New: ${newCount}</span>
                        <span class="summary-item duplicate">Duplicates: ${duplicateCount}</span>
                        <span class="summary-item total">Total: ${words.length}</span>
                    `;
                }
                
                // Create category filters
                const categories = [...new Set(analyzedWords.map(w => w.category))].sort();
                const categoryContainer = document.getElementById('upload-preview-categories');
                if (categoryContainer) {
                    let categoryHTML = '';
                    if (categories.length > 0) {
                        categoryHTML = `
                            <div class="category-filters-label">Filter by Category:</div>
                            <div class="category-filters-grid">
                                ${categories.map(cat => `
                                    <button class="category-filter-btn" onclick="toggleCategoryFilter('${cat}')">
                                        ${cat.charAt(0).toUpperCase() + cat.slice(1)}
                                    </button>
                                `).join('')}
                            </div>
                        `;
                    }
                    categoryContainer.innerHTML = categoryHTML;
                }
                
                // Display words
                updatePreviewDisplay();
                
                // Show preview modal
                const modal = document.getElementById('upload-preview-modal');
                if (modal) {
                    modal.classList.remove('hidden');
                    modal.style.display = 'flex';
                    console.log('Preview modal shown');
                    devLog('Preview modal displayed', 'success');
                } else {
                    console.error('Upload preview modal element not found');
                    alert('Preview modal not found. Please refresh the page.');
                }
            } catch (error) {
                console.error('Error in showUploadPreview:', error);
                devLog(`Error showing preview: ${error.message}`, 'error');
                alert(`Error showing preview: ${error.message}`);
            }
        }

        window.updatePreviewDisplay = function() {
            if (!pendingUpload) return;
            
            const viewMode = document.getElementById('preview-view-mode').value;
            const sortBy = document.getElementById('preview-sort-language').value;
            let wordsToDisplay = [...pendingUpload.words];
            
            // Apply status filter
            if (currentFilter === 'new') {
                wordsToDisplay = wordsToDisplay.filter(w => w.status === 'new');
            } else if (currentFilter === 'duplicate') {
                wordsToDisplay = wordsToDisplay.filter(w => w.status === 'duplicate');
            }
            
            // Apply category filter
            if (activeCategories.size > 0) {
                wordsToDisplay = wordsToDisplay.filter(w => activeCategories.has(w.category));
            }
            
            // Sort words
            wordsToDisplay.sort((a, b) => {
                const fieldA = sortBy === 'source' ? a.word : a.translation;
                const fieldB = sortBy === 'source' ? b.word : b.translation;
                return fieldA.toLowerCase().localeCompare(fieldB.toLowerCase());
            });
            
            // Build HTML based on view mode
            let html = '';
            
            if (viewMode === 'category') {
                // Group by category
                const grouped = {};
                wordsToDisplay.forEach((word, originalIndex) => {
                    if (!grouped[word.category]) {
                        grouped[word.category] = [];
                    }
                    grouped[word.category].push({ ...word, originalIndex: pendingUpload.words.indexOf(word) });
                });
                
                // Sort categories alphabetically
                Object.keys(grouped).sort().forEach(category => {
                    const categoryWords = grouped[category];
                    html += `
                        <div class="preview-category-section">
                            <div class="preview-category-header">
                                <span>${category.charAt(0).toUpperCase() + category.slice(1)}</span>
                                <span class="preview-category-count">${categoryWords.length} words</span>
                            </div>`;
                    
                    categoryWords.forEach(word => {
                        html += createPreviewItemHTML(word, word.originalIndex);
                    });
                    
                    html += '</div>';
                });
            } else {
                // Alphabetical view without categories
                wordsToDisplay.forEach(word => {
                    const originalIndex = pendingUpload.words.indexOf(word);
                    html += createPreviewItemHTML(word, originalIndex);
                });
            }
            
            const listElement = document.getElementById('upload-preview-list');
            if (listElement) {
                listElement.innerHTML = html || '<p style="text-align: center; color: #999;">No words match the current filters</p>';
            }
        }

        function createPreviewItemHTML(word, index) {
            const statusClass = word.status;
            const statusText = word.status === 'new' ? 'NEW' : 'DUPLICATE';
            const checked = word.selected ? 'checked' : '';
            
            return `
                <div class="preview-item ${statusClass}" data-index="${index}" data-status="${statusClass}">
                    <input type="checkbox" class="preview-checkbox" ${checked} onchange="toggleWordSelection(${index})">
                    <div class="preview-item-content">
                        <div class="preview-word">${word.word}</div>
                        <div class="preview-translation">${word.translation} ${word.romanization ? `(${word.romanization})` : ''}</div>
                        ${word.status === 'duplicate' ? `
                            <div class="preview-duplicate-info">
                                Existing: ${word.existingWord.translation} 
                                ${word.existingWord.romanization ? `(${word.existingWord.romanization})` : ''}
                            </div>
                        ` : ''}
                    </div>
                    <span class="preview-status ${statusClass}">${statusText}</span>
                </div>
            `;
        }

        window.toggleFilterSection = function() {
            const filterContent = document.getElementById('filter-content');
            const toggleIcon = document.getElementById('filter-toggle-icon');
            
            if (filterContent.classList.contains('collapsed')) {
                filterContent.classList.remove('collapsed');
                toggleIcon.classList.remove('collapsed');
                toggleIcon.textContent = '▼';
            } else {
                filterContent.classList.add('collapsed');
                toggleIcon.classList.add('collapsed');
                toggleIcon.textContent = '▶';
            }
        }

        window.toggleCategoryFilter = function(category) {
            const btn = event.target;
            
            if (activeCategories.has(category)) {
                activeCategories.delete(category);
                btn.classList.remove('active');
            } else {
                activeCategories.add(category);
                btn.classList.add('active');
            }
            
            updatePreviewDisplay();
        }

        window.selectAllWords = function(select) {
            if (pendingUpload) {
                pendingUpload.words.forEach(word => {
                    word.selected = select;
                });
                
                // Update all checkboxes
                document.querySelectorAll('.preview-checkbox').forEach(checkbox => {
                    checkbox.checked = select;
                });
            }
        }

        window.toggleWordSelection = function(index) {
            if (pendingUpload && pendingUpload.words[index]) {
                pendingUpload.words[index].selected = !pendingUpload.words[index].selected;
            }
        }

        window.filterPreview = function(filter) {
            currentFilter = filter;
            
            // Update filter button states
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            updatePreviewDisplay();
        }

        window.cancelUploadPreview = function() {
            pendingUpload = null;
            currentFilter = 'all';
            activeCategories.clear();
            document.getElementById('upload-preview-modal').classList.add('hidden');
            document.getElementById('upload-preview-modal').style.display = 'none';
        }

        window.confirmUpload = function() {
            if (!pendingUpload) return;
            
            const strategy = document.getElementById('duplicate-strategy').value;
            const languagePair = pendingUpload.languagePair;
            const selectedWords = pendingUpload.words.filter(w => w.selected);
            
            let addedCount = 0;
            let skippedCount = 0;
            let replacedCount = 0;
            
            // Initialize user vocabulary if needed
            if (!userVocabulary[languagePair]) {
                userVocabulary[languagePair] = [];
            }
            
            // Get max ID
            const existingIds = [
                ...(vocabularyData[languagePair] || []).map(w => w.id),
                ...(userVocabulary[languagePair] || []).map(w => w.id)
            ];
            let maxId = Math.max(...existingIds, 1000);
            
            selectedWords.forEach(word => {
                if (word.status === 'new') {
                    // Add new word
                    if (!word.id) {
                        word.id = ++maxId;
                    }
                    userVocabulary[languagePair].push(word);
                    addedCount++;
                } else if (word.status === 'duplicate') {
                    // Handle duplicate based on strategy
                    if (strategy === 'skip') {
                        skippedCount++;
                    } else if (strategy === 'replace') {
                        // Find and replace existing word
                        const existingIndex = userVocabulary[languagePair].findIndex(w => 
                            w.word.toLowerCase() === word.word.toLowerCase()
                        );
                        if (existingIndex !== -1) {
                            word.id = userVocabulary[languagePair][existingIndex].id;
                            userVocabulary[languagePair][existingIndex] = word;
                        } else {
                            // It's in the main vocabulary, so add to user vocabulary as override
                            if (!word.id) {
                                word.id = ++maxId;
                            }
                            userVocabulary[languagePair].push(word);
                        }
                        replacedCount++;
                    } else if (strategy === 'add') {
                        // Add as alternate translation
                        if (!word.id) {
                            word.id = ++maxId;
                        }
                        word.word = word.word + ' (alt)'; // Mark as alternate
                        userVocabulary[languagePair].push(word);
                        addedCount++;
                    }
                }
            });
            
            // Save to localStorage
            localStorage.setItem('userVocabulary', JSON.stringify(userVocabulary));
            
            // Track file
            if (!vocabularyFiles[languagePair]) {
                vocabularyFiles[languagePair] = [];
            }
            vocabularyFiles[languagePair].push({
                name: pendingUpload.file.name,
                wordCount: selectedWords.length,
                uploadedAt: new Date().toISOString()
            });
            localStorage.setItem('vocabularyFiles', JSON.stringify(vocabularyFiles));
            
            // Update main vocabulary data
            vocabularyData[languagePair] = [
                ...(vocabularyData[languagePair] || []),
                ...userVocabulary[languagePair]
            ];
            
            // Show result message
            let message = `Import complete!\n`;
            if (addedCount > 0) message += `✓ Added: ${addedCount} words\n`;
            if (replacedCount > 0) message += `✓ Replaced: ${replacedCount} words\n`;
            if (skippedCount > 0) message += `✓ Skipped: ${skippedCount} duplicates`;
            
            alert(message);
            
            // Close preview and refresh display
            cancelUploadPreview();
            displayVocabulary(currentVocabTab);
            
            devLog(`Import complete: ${addedCount} added, ${replacedCount} replaced, ${skippedCount} skipped`, 'success');
        }

        async function handleFiles(files) {
            for (const file of files) {
                if (file.type === 'application/json' || file.name.endsWith('.json')) {
                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);
                        
                        // Validate structure
                        if (data.words && Array.isArray(data.words)) {
                            const metadata = data.metadata || {};
                            const languagePair = metadata.language_pair || currentVocabTab;
                            
                            // Show preview instead of directly importing
                            showUploadPreview(file, data, languagePair);
                        } else {
                            alert(`Invalid file format in ${file.name}. Expected JSON with 'words' array.`);
                        }
                    } catch (error) {
                        devLog(`Error processing ${file.name}: ${error.message}`, 'error');
                        alert(`Error processing ${file.name}: ${error.message}`);
                    }
                } else {
                    alert(`${file.name} is not a JSON file`);
                }
            }
        }

        // Make functions globally accessible
        window.openVocabManager = function() {
            console.log('openVocabManager called');
            devLog('Opening Vocabulary Manager...', 'info');
            
            try {
                toggleSettings(); // Close settings menu
                
                const vocabManager = document.getElementById('vocab-manager');
                if (!vocabManager) {
                    console.error('Vocabulary Manager element not found!');
                    alert('Vocabulary Manager element not found!');
                    return;
                }
                
                vocabManager.classList.remove('hidden');
                vocabManager.style.display = 'flex';
                
                currentVocabTab = currentLanguagePair || 'cs-vi';
                switchVocabTab(currentVocabTab);
                loadVocabManagerData();
                
                devLog('Vocabulary Manager opened', 'success');
            } catch (error) {
                console.error('Error opening vocabulary manager:', error);
                alert('Error opening vocabulary manager: ' + error.message);
            }
        }

        window.closeVocabManager = function() {
            const vocabManager = document.getElementById('vocab-manager');
            if (vocabManager) {
                vocabManager.classList.add('hidden');
                vocabManager.style.display = 'none';
            }
        }

        window.switchVocabTab = function(lang) {
            currentVocabTab = lang;
            
            // Update tab UI
            document.querySelectorAll('.vocab-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.lang === lang) {
                    tab.classList.add('active');
                }
            });
            
            displayVocabulary(lang);
        }

        window.searchVocabulary = function(query) {
            const items = document.querySelectorAll('.vocab-item');
            const categories = document.querySelectorAll('.vocab-category');
            const searchTerm = query.toLowerCase();
            
            if (!searchTerm) {
                // Show all
                items.forEach(item => item.style.display = 'flex');
                categories.forEach(cat => cat.style.display = 'block');
                return;
            }
            
            // Hide/show based on search
            categories.forEach(category => {
                let hasVisibleItems = false;
                const categoryItems = category.querySelectorAll('.vocab-item');
                
                categoryItems.forEach(item => {
                    const word = item.dataset.word || '';
                    const translation = item.dataset.translation || '';
                    
                    if (word.includes(searchTerm) || translation.includes(searchTerm)) {
                        item.style.display = 'flex';
                        hasVisibleItems = true;
                    } else {
                        item.style.display = 'none';
                    }
                });
                
                category.style.display = hasVisibleItems ? 'block' : 'none';
            });
        }

        // GitHub Integration Functions
        window.switchUploadTab = function(tab) {
            // Update tab buttons
            document.querySelectorAll('.upload-tab').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Show/hide tab content
            document.getElementById('local-upload').style.display = tab === 'local' ? 'block' : 'none';
            document.getElementById('github-upload').style.display = tab === 'github' ? 'block' : 'none';
        }

        window.loadFromGitHub = async function() {
            const urlInput = document.getElementById('github-url');
            const statusDiv = document.getElementById('github-status');
            const loadBtn = document.querySelector('.github-load-btn');
            
            const githubUrl = urlInput.value.trim();
            
            if (!githubUrl) {
                statusDiv.className = 'github-status error';
                statusDiv.textContent = 'Please enter a GitHub URL';
                return;
            }
            
            // Parse GitHub URL to get API endpoint
            const apiUrl = parseGitHubUrl(githubUrl);
            
            if (!apiUrl) {
                statusDiv.className = 'github-status error';
                statusDiv.textContent = 'Invalid GitHub URL format. Please use: https://github.com/username/repo/tree/branch/path';
                return;
            }
            
            // Show loading status
            statusDiv.className = 'github-status loading';
            statusDiv.textContent = 'Loading vocabulary files from GitHub...';
            loadBtn.disabled = true;
            
            try {
                // Fetch directory contents from GitHub API
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`GitHub API error: ${response.status}`);
                }
                
                const files = await response.json();
                
                // Filter for JSON files
                const jsonFiles = files.filter(file => file.name.endsWith('.json'));
                
                if (jsonFiles.length === 0) {
                    statusDiv.className = 'github-status error';
                    statusDiv.textContent = 'No JSON files found in the specified directory';
                    loadBtn.disabled = false;
                    return;
                }
                
                // Load each JSON file
                let loadedCount = 0;
                let totalWords = 0;
                
                for (const file of jsonFiles) {
                    try {
                        statusDiv.textContent = `Loading ${file.name}...`;
                        
                        // Fetch file content
                        const contentResponse = await fetch(file.download_url);
                        if (!contentResponse.ok) continue;
                        
                        const content = await contentResponse.text();
                        const data = JSON.parse(content);
                        
                        // Process as if it was uploaded
                        if (data.words && Array.isArray(data.words)) {
                            const metadata = data.metadata || {};
                            const languagePair = metadata.language_pair || currentVocabTab;
                            
                            // Create a fake File object for compatibility
                            const fakeFile = { name: file.name };
                            
                            // Show preview for each file
                            showUploadPreview(fakeFile, data, languagePair);
                            loadedCount++;
                            totalWords += data.words.length;
                            
                            // Store GitHub source info
                            if (!window.githubSources) {
                                window.githubSources = {};
                            }
                            if (!window.githubSources[languagePair]) {
                                window.githubSources[languagePair] = [];
                            }
                            window.githubSources[languagePair].push({
                                url: githubUrl,
                                file: file.name,
                                loadedAt: new Date().toISOString()
                            });
                            
                            // Save GitHub source to localStorage
                            localStorage.setItem('githubSources', JSON.stringify(window.githubSources));
                        }
                    } catch (error) {
                        console.error(`Error loading ${file.name}:`, error);
                    }
                }
                
                if (loadedCount > 0) {
                    statusDiv.className = 'github-status success';
                    statusDiv.textContent = `Successfully loaded ${loadedCount} file(s) with ${totalWords} words total`;
                    
                    // Save the GitHub URL for future use
                    localStorage.setItem('lastGitHubUrl', githubUrl);
                } else {
                    statusDiv.className = 'github-status error';
                    statusDiv.textContent = 'No valid vocabulary files could be loaded';
                }
                
            } catch (error) {
                console.error('GitHub loading error:', error);
                statusDiv.className = 'github-status error';
                statusDiv.textContent = `Error: ${error.message}. Make sure the repository is public.`;
            } finally {
                loadBtn.disabled = false;
            }
        }

        function parseGitHubUrl(url) {
            // Parse various GitHub URL formats
            // https://github.com/username/repo/tree/branch/path
            // https://github.com/username/repo/tree/main/vocabulary
            
            const patterns = [
                /github\.com\/([^\/]+)\/([^\/]+)\/tree\/([^\/]+)\/(.*)/,
                /github\.com\/([^\/]+)\/([^\/]+)\/tree\/([^\/]+)$/,
                /github\.com\/([^\/]+)\/([^\/]+)$/
            ];
            
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match) {
                    const owner = match[1];
                    const repo = match[2];
                    const branch = match[3] || 'main';
                    const path = match[4] || '';
                    
                    // Construct GitHub API URL
                    let apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/`;
                    if (path) {
                        apiUrl += path;
                    }
                    apiUrl += `?ref=${branch}`;
                    
                    return apiUrl;
                }
            }
            
            return null;
        }

        // Auto-load from GitHub on startup if configured
        window.addEventListener('load', async () => {
            const lastGitHubUrl = localStorage.getItem('lastGitHubUrl');
            if (lastGitHubUrl) {
                const urlInput = document.getElementById('github-url');
                if (urlInput) {
                    urlInput.value = lastGitHubUrl;
                    devLog(`Last GitHub URL found: ${lastGitHubUrl}`, 'info');
                }
            }
        });

        // File upload handling - make globally accessible
        window.handleDragOver = function(e) {
            e.preventDefault();
            e.stopPropagation();
            document.getElementById('upload-zone').classList.add('dragover');
        }

        window.handleDragLeave = function(e) {
            e.preventDefault();
            e.stopPropagation();
            document.getElementById('upload-zone').classList.remove('dragover');
        }

        window.handleDrop = function(e) {
            e.preventDefault();
            e.stopPropagation();
            document.getElementById('upload-zone').classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            window.handleFiles(files);
        }

        window.handleFileSelect = function(e) {
            const files = e.target.files;
            if (files.length > 0) {
                window.handleFiles(files);
                // Reset the file input so the same file can be selected again
                e.target.value = '';
            }
        }
        
        window.handleFiles = async function(files) {
            console.log('handleFiles called with', files.length, 'files');
            
            for (const file of files) {
                console.log('Processing file:', file.name, file.type);
                
                if (file.type === 'application/json' || file.name.endsWith('.json')) {
                    try {
                        const text = await file.text();
                        console.log('File text read, length:', text.length);
                        
                        const data = JSON.parse(text);
                        console.log('JSON parsed, words count:', data.words ? data.words.length : 0);
                        
                        // Validate structure
                        if (data.words && Array.isArray(data.words)) {
                            const metadata = data.metadata || {};
                            const languagePair = metadata.language_pair || currentVocabTab;
                            
                            console.log('Calling showUploadPreview for', languagePair);
                            // Show preview instead of directly importing
                            showUploadPreview(file, data, languagePair);
                        } else {
                            alert(`Invalid file format in ${file.name}. Expected JSON with 'words' array.`);
                        }
                    } catch (error) {
                        console.error('Error in handleFiles:', error);
                        devLog(`Error processing ${file.name}: ${error.message}`, 'error');
                        alert(`Error processing ${file.name}: ${error.message}`);
                    }
                } else {
                    alert(`${file.name} is not a JSON file`);
                }
            }
        }

        async function handleFiles(files) {
            for (const file of files) {
                if (file.type === 'application/json') {
                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);
                        
                        // Validate structure
                        if (data.words && Array.isArray(data.words)) {
                            const metadata = data.metadata || {};
                            const languagePair = metadata.language_pair || currentVocabTab;
                            
                            // Add to user vocabulary
                            if (!userVocabulary[languagePair]) {
                                userVocabulary[languagePair] = [];
                            }
                            
                            // Add words with unique IDs
                            const maxId = Math.max(...vocabularyData[languagePair].map(w => w.id), 1000);
                            data.words.forEach((word, index) => {
                                if (!word.id) {
                                    word.id = maxId + index + 1;
                                }
                                userVocabulary[languagePair].push(word);
                            });
                            
                            // Track file
                            if (!vocabularyFiles[languagePair]) {
                                vocabularyFiles[languagePair] = [];
                            }
                            vocabularyFiles[languagePair].push({
                                name: file.name,
                                wordCount: data.words.length,
                                uploadedAt: new Date().toISOString()
                            });
                            
                            // Save to localStorage
                            localStorage.setItem('userVocabulary', JSON.stringify(userVocabulary));
                            localStorage.setItem('vocabularyFiles', JSON.stringify(vocabularyFiles));
                            
                            // Update main vocabulary data
                            vocabularyData[languagePair] = [...vocabularyData[languagePair], ...data.words];
                            
                            devLog(`Uploaded ${data.words.length} words from ${file.name}`, 'success');
                            alert(`Successfully added ${data.words.length} words from ${file.name}`);
                            
                            // Refresh display
                            displayVocabulary(currentVocabTab);
                        } else {
                            alert(`Invalid file format in ${file.name}. Expected JSON with 'words' array.`);
                        }
                    } catch (error) {
                        devLog(`Error processing ${file.name}: ${error.message}`, 'error');
                        alert(`Error processing ${file.name}: ${error.message}`);
                    }
                } else {
                    alert(`${file.name} is not a JSON file`);
                }
            }
        }

        function exportVocabulary() {
            const lang = currentVocabTab;
            const vocab = [...(vocabularyData[lang] || []), ...(userVocabulary[lang] || [])];
            
            const exportData = {
                metadata: {
                    language_pair: lang,
                    exported_at: new Date().toISOString(),
                    word_count: vocab.length
                },
                words: vocab
            };
            
            const json = JSON.stringify(exportData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `vocabulary-${lang}-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ============= SETTINGS MENU FUNCTIONS =============
        function toggleSettings() {
            const menu = document.getElementById('settings-menu');
            const overlay = document.getElementById('settings-overlay');
            
            if (menu.classList.contains('open')) {
                menu.classList.remove('open');
                overlay.classList.remove('open');
            } else {
                menu.classList.add('open');
                overlay.classList.add('open');
            }
        }

        function openVocabManager() {
            alert('Vocabulary Manager coming soon! This will allow you to:\n\n' +
                  '• View all loaded vocabulary\n' +
                  '• Upload custom vocabulary files\n' +
                  '• Toggle files on/off\n' +
                  '• Search and filter words');
            toggleSettings();
        }

        function showStatistics() {
            const data = loadProgress();
            let stats = 'Learning Statistics\n\n';
            
            // Count words by skill level
            let skillCounts = { 1: 0, 2: 0, 3: 0 };
            let totalWords = 0;
            
            if (data.progress) {
                Object.values(data.progress).forEach(langPair => {
                    Object.values(langPair).forEach(card => {
                        totalWords++;
                        const level = card.skillLevel || 1;
                        skillCounts[level]++;
                    });
                });
            }
            
            stats += `Total Words Seen: ${totalWords}\n`;
            stats += `Beginner Level: ${skillCounts[1]}\n`;
            stats += `Intermediate Level: ${skillCounts[2]}\n`;
            stats += `Advanced Level: ${skillCounts[3]}\n\n`;
            stats += `Current Streak: ${data.streak || 0} days\n`;
            stats += `Overall Accuracy: ${data.accuracy?.total ? Math.round((data.accuracy.correct / data.accuracy.total) * 100) : 0}%`;
            
            alert(stats);
            toggleSettings();
        }

        function exportProgress() {
            const data = loadProgress();
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `language-learning-progress-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            toggleSettings();
        }

        function resetAllData() {
            if (confirm('Are you sure you want to reset all data? This cannot be undone!')) {
                localStorage.clear();
                location.reload();
            }
        }

        // ============= LONG-PRESS SKILL SWITCHING =============
        let longPressTimer = null;
        let isLongPress = false;

        function setupSkillPillLongPress() {
            document.querySelectorAll('.skill-pill').forEach(pill => {
                // Remove any existing listeners first
                pill.replaceWith(pill.cloneNode(true));
            });
            
            // Re-select after cloning
            document.querySelectorAll('.skill-pill').forEach(pill => {
                // Desktop: Simple click on inactive pills
                pill.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const level = parseInt(pill.dataset.level);
                    
                    // If clicking an inactive pill, switch to it
                    if (!pill.classList.contains('active') && level) {
                        devLog(`Desktop: Switching to ${SKILL_NAMES[level]} via click`, 'info');
                        switchSkillLevel(level);
                    }
                });
                
                // Mobile: Long press on active pill (keep existing behavior)
                pill.addEventListener('touchstart', startLongPress, { passive: false });
                pill.addEventListener('touchend', cancelLongPress);
                pill.addEventListener('touchcancel', cancelLongPress);
                pill.addEventListener('touchmove', cancelLongPress);
                
                // Prevent default actions
                pill.addEventListener('contextmenu', (e) => e.preventDefault());
                pill.addEventListener('dragstart', (e) => e.preventDefault());
            });
        }

        function startLongPress(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const pill = e.currentTarget;
            
            // Only allow long-press on the active pill for mobile
            if (!pill.classList.contains('active')) {
                return;
            }
            
            // Cancel any existing timer
            if (longPressTimer) {
                clearTimeout(longPressTimer);
            }
            
            devLog(`Mobile: Long press started on ${pill.textContent} pill`, 'info');
            
            isLongPress = false;
            longPressTimer = setTimeout(() => {
                isLongPress = true;
                devLog('Mobile: Long press triggered - showing menu', 'success');
                showSkillSwitchMenu(e, pill);
            }, 500);
        }

        function cancelLongPress(e) {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
        }

        function showSkillSwitchMenu(e, pill) {
            const menu = document.getElementById('skill-switch-menu');
            menu.classList.remove('hidden');
            
            // Position the menu based on the pill's position
            const rect = pill.getBoundingClientRect();
            menu.style.left = rect.left + 'px';
            menu.style.top = (rect.bottom + 5) + 'px';
            
            // Mark current level
            document.querySelectorAll('.skill-switch-option').forEach(option => {
                option.classList.remove('current');
                if (parseInt(option.dataset.level) === currentCardSkillLevel) {
                    option.classList.add('current');
                }
            });
            
            // Hide menu when touching elsewhere (mobile only)
            setTimeout(() => {
                const hideHandler = (e) => {
                    if (!menu.contains(e.target)) {
                        hideSkillSwitchMenu();
                    }
                };
                document.addEventListener('touchstart', hideHandler, { once: true });
            }, 100);
        }

        function hideSkillSwitchMenu() {
            document.getElementById('skill-switch-menu').classList.add('hidden');
        }

        function switchSkillLevel(level) {
            currentCardSkillLevel = level;
            devLog(`Manually switched to ${SKILL_NAMES[level]} level for current card`, 'info');
            
            // Hide the menu first
            hideSkillSwitchMenu();
            
            // Update the UI to reflect the change
            updateCardSkillDisplay(currentSession[currentCardIndex].id);
            
            // Reset answer state
            isAnswerShown = false;
            selectedChoiceIndex = -1;
            
            // Clear any existing feedback
            document.getElementById('feedback').classList.add('hidden');
            
            // Re-show the card with new skill level (preserve the manually selected level)
            showCard(true);
        }

        // ============= APP STATE =============
        let currentLanguagePair = 'cs-vi';
        let currentSession = [];
        let pausedSession = null;
        let currentCardIndex = 0;
        let sessionStats = {
            correct: 0,
            total: 0,
            startTime: null,
            wordsCompleted: []
        };
        let isAnswerShown = false;
        let dailyGoal = {
            new: 3,
            review: 5,
            completed: { new: 0, review: 0 },
            adaptiveFactor: 1.0
        };
        let defaultSkillLevel = 0; // 0 = Auto, 1-3 = Manual levels
        let currentCardSkillLevel = 1; // Current card's skill level
        let selectedChoiceIndex = -1; // For multiple choice

        // Local Storage Keys
        const STORAGE_KEY = 'languageApp';

        // ============= INITIALIZATION =============
        async function initApp() {
            devLog('Initializing app with vocabulary system...', 'info');
            
            // Initialize vocabulary first
            await initializeVocabulary();
            
            // Ensure proper initial screen state
            document.getElementById('home-content').style.display = 'block';
            document.getElementById('study-screen').classList.add('hidden');
            document.getElementById('study-screen').style.display = 'none';
            document.getElementById('complete-screen').classList.add('hidden');
            document.getElementById('complete-screen').style.display = 'none';
            document.getElementById('main-container').classList.remove('study-mode');
            
            loadProgress();
            updateDailyGoal();
            updateStats();
            setupEventListeners();
            checkPausedSession();
            updateSessionHistory();
            updateSkillLevelDisplay();
            setupSkillPillLongPress();
            
            devLog('App initialized successfully', 'success');
        }

        // ============= EVENT LISTENERS =============
        function setupEventListeners() {
            document.querySelectorAll('.language-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.language-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentLanguagePair = this.dataset.pair;
                    updateDailyGoal();
                    checkPausedSession();
                });
            });

            document.getElementById('answer').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    handleButtonClick();
                }
            });
        }

        // ============= SKILL LEVEL FUNCTIONS =============
        function setDefaultSkillLevel(level) {
            defaultSkillLevel = level;
            updateSkillLevelDisplay();
            
            const data = loadProgress();
            data.defaultSkillLevel = level;
            saveProgress(data);
            
            devLog(`Default skill level set to: ${level === 0 ? 'Auto' : SKILL_NAMES[level]}`, 'info');
        }

        function updateSkillLevelDisplay() {
            document.querySelectorAll('.skill-level-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.level) === defaultSkillLevel) {
                    btn.classList.add('active');
                }
            });
        }

        function determineCardSkillLevel(cardId) {
            const data = loadProgress();
            const cardProgress = data.progress?.[currentLanguagePair]?.[cardId];
            
            if (!cardProgress) {
                // New card - use default or beginner
                return defaultSkillLevel === 0 ? SKILL_LEVELS.BEGINNER : defaultSkillLevel;
            }
            
            // Auto mode
            if (defaultSkillLevel === 0) {
                // Use recommended skill level or last used
                return cardProgress.recommendedSkillLevel || cardProgress.skillLevel || SKILL_LEVELS.BEGINNER;
            }
            
            // Manual mode - use selected level
            return defaultSkillLevel;
        }

        function updateCardSkillDisplay(cardId) {
            const data = loadProgress();
            const cardProgress = data.progress?.[currentLanguagePair]?.[cardId];
            
            // Update skill pills
            document.querySelectorAll('.skill-pill').forEach(pill => {
                pill.classList.remove('active');
                if (parseInt(pill.dataset.level) === currentCardSkillLevel) {
                    pill.classList.add('active');
                }
            });
            
            // Check for promotion (only if card has progress)
            if (cardProgress && cardProgress.skillProgress) {
                checkSkillPromotion(cardProgress);
            }
        }
        
        function checkSkillPromotion(cardProgress) {
            const currentStats = cardProgress.skillProgress[currentCardSkillLevel] || { streak: 0, correct: 0, total: 0 };
            
            if (currentCardSkillLevel < 3 && 
                currentStats.streak >= PROMOTION_THRESHOLD.streak && 
                currentStats.total >= 3 &&
                (currentStats.correct / currentStats.total) >= PROMOTION_THRESHOLD.accuracy) {
                
                cardProgress.recommendedSkillLevel = currentCardSkillLevel + 1;
                devLog(`Card ready for promotion to ${SKILL_NAMES[currentCardSkillLevel + 1]}!`, 'success');
            }
        }

        // ============= MULTIPLE CHOICE FUNCTIONS =============
        function generateMultipleChoice(correctCard, allCards) {
            // Filter for good distractors
            const distractors = allCards
                .filter(c => c.id !== correctCard.id)
                .sort((a, b) => {
                    // Prioritize same category
                    if (a.category === correctCard.category && b.category !== correctCard.category) return -1;
                    if (b.category === correctCard.category && a.category !== correctCard.category) return 1;
                    // Then similar difficulty
                    const aDiff = Math.abs(a.difficulty - correctCard.difficulty);
                    const bDiff = Math.abs(b.difficulty - correctCard.difficulty);
                    return aDiff - bDiff;
                })
                .slice(0, 3);
            
            // Shuffle options
            const options = [correctCard, ...distractors].sort(() => Math.random() - 0.5);
            
            return options.map((option, index) => ({
                text: option.translation,
                romanization: option.romanization,
                isCorrect: option.id === correctCard.id,
                index: index
            }));
        }

        function renderMultipleChoice(options) {
            const grid = document.getElementById('choice-grid');
            grid.innerHTML = '';
            grid.classList.remove('hidden');
            
            options.forEach((option, index) => {
                const btn = document.createElement('button');
                btn.className = 'choice-btn';
                btn.onclick = () => selectChoice(index);
                btn.innerHTML = `
                    <span class="choice-text">${option.text}</span>
                    ${option.romanization ? `<span class="choice-romanization">${option.romanization}</span>` : ''}
                `;
                btn.dataset.index = index;
                btn.dataset.correct = option.isCorrect;
                grid.appendChild(btn);
            });
        }

        function selectChoice(index) {
            if (isAnswerShown) return;
            
            // Clear previous selection
            document.querySelectorAll('.choice-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // Mark new selection
            const btn = document.querySelector(`.choice-btn[data-index="${index}"]`);
            btn.classList.add('selected');
            selectedChoiceIndex = index;
        }

        // ============= ANSWER VALIDATION =============
        function normalizeAnswer(text) {
            return text
                .toLowerCase()
                .normalize('NFD')  // Decompose diacritics
                .replace(/[\u0300-\u036f]/g, '') // Remove diacritics
                .replace(/[^a-z0-9\u4e00-\u9fff]/g, ''); // Keep alphanumeric and Chinese chars
        }

        function levenshteinDistance(str1, str2) {
            const matrix = [];
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[str2.length][str1.length];
        }

        function checkIntermediateAnswer(userAnswer, correctAnswer) {
            const normalized = normalizeAnswer(userAnswer);
            const correct = normalizeAnswer(correctAnswer);
            
            // Exact match (normalized)
            if (normalized === correct) return true;
            
            // Allow 1 character difference for typos
            if (levenshteinDistance(normalized, correct) <= 1) return true;
            
            return false;
        }

        // ============= CORE FUNCTIONS =============
        function handleButtonClick() {
            const button = document.getElementById('action-button');
            if (button.classList.contains('next')) {
                nextCard();
            } else {
                checkAnswer();
            }
        }

        function loadProgress() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                const data = JSON.parse(saved);
                
                // Migrate old data to include skill levels
                if (data.progress) {
                    Object.keys(data.progress).forEach(lang => {
                        Object.keys(data.progress[lang]).forEach(cardId => {
                            const card = data.progress[lang][cardId];
                            if (!card.skillLevel) {
                                card.skillLevel = 1;
                                card.skillProgress = {
                                    1: { correct: 0, total: 0, streak: 0 },
                                    2: { correct: 0, total: 0, streak: 0 },
                                    3: { correct: 0, total: 0, streak: 0 }
                                };
                                card.recommendedSkillLevel = 1;
                            }
                        });
                    });
                }
                
                // Check if it's a new day
                const today = new Date().toDateString();
                if (data.lastStudied !== today) {
                    data.dailyProgress = {
                        new: 0,
                        review: 0,
                        sessions: [],
                        timeSpent: 0,
                        cardsSeen: {}
                    };
                    
                    const yesterday = new Date(Date.now() - 86400000).toDateString();
                    if (data.lastStudied === yesterday && data.dailyProgress?.completed) {
                        data.streak = (data.streak || 0) + 1;
                    } else if (data.lastStudied !== yesterday) {
                        data.streak = 0;
                    }
                    
                    data.lastStudied = today;
                    saveProgress(data);
                }
                
                // Load saved default skill level
                if (data.defaultSkillLevel !== undefined) {
                    defaultSkillLevel = data.defaultSkillLevel;
                }
                
                // Load daily goal adjustments
                if (data.adaptiveGoal) {
                    dailyGoal = { ...dailyGoal, ...data.adaptiveGoal };
                }
                
                return data;
            }
            
            // Initialize new user data
            const newData = {
                progress: {},
                streak: 0,
                lastStudied: new Date().toDateString(),
                dailyProgress: {
                    new: 0,
                    review: 0,
                    sessions: [],
                    timeSpent: 0,
                    cardsSeen: {}
                },
                accuracy: { correct: 0, total: 0 },
                totalLearned: 0,
                adaptiveGoal: dailyGoal,
                defaultSkillLevel: 0
            };
            saveProgress(newData);
            return newData;
        }

        function saveProgress(data) {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        }

        function updateDailyGoal() {
            const data = loadProgress();
            const dailyProgress = data.dailyProgress || { new: 0, review: 0 };
            
            const totalGoal = dailyGoal.new + dailyGoal.review;
            const totalComplete = dailyProgress.new + dailyProgress.review;
            
            document.getElementById('goal-progress').textContent = `${totalComplete}/${totalGoal}`;
            document.getElementById('goal-bar').style.width = `${(totalComplete / totalGoal) * 100}%`;
            document.getElementById('words-new').textContent = `New: ${dailyProgress.new}/${dailyGoal.new}`;
            document.getElementById('words-review').textContent = `Review: ${dailyProgress.review}/${dailyGoal.review}`;
            document.getElementById('time-spent').textContent = `Time: ${Math.round(dailyProgress.timeSpent || 0)} min`;
            
            const remainingWords = totalGoal - totalComplete;
            const estimatedTime = Math.max(0, remainingWords * 1);
            document.getElementById('time-estimate').textContent = 
                remainingWords > 0 ? `~${estimatedTime} minutes remaining today` : `Daily goal complete! 🎉`;
            
            document.getElementById('all-time').textContent = `~${remainingWords} min`;
        }

        function updateSessionProgress() {
            if (currentSession.length === 0) return;
            
            const progress = ((currentCardIndex) / currentSession.length) * 100;
            document.getElementById('session-bar').style.width = `${progress}%`;
            document.getElementById('session-correct').textContent = `Correct: ${sessionStats.correct}`;
            
            const accuracy = sessionStats.total > 0 
                ? Math.round((sessionStats.correct / sessionStats.total) * 100) 
                : 0;
            document.getElementById('session-accuracy').textContent = `Accuracy: ${accuracy}%`;
        }

        function updateStats() {
            const data = loadProgress();
            document.getElementById('streak').textContent = data.streak || 0;
            
            // Count mastered words (Advanced level with high accuracy)
            let masteredCount = 0;
            if (data.progress) {
                Object.values(data.progress).forEach(langPair => {
                    Object.values(langPair).forEach(card => {
                        const advancedStats = card.skillProgress?.[3];
                        if (advancedStats && advancedStats.total >= 3 && 
                            (advancedStats.correct / advancedStats.total) >= 0.8) {
                            masteredCount++;
                        }
                    });
                });
            }
            document.getElementById('total-learned').textContent = masteredCount;
            
            if (data.accuracy && data.accuracy.total > 0) {
                const acc = Math.round((data.accuracy.correct / data.accuracy.total) * 100);
                document.getElementById('accuracy').textContent = acc + '%';
            }
        }

        function checkPausedSession() {
            const data = loadProgress();
            if (data.pausedSession && data.pausedSession.languagePair === currentLanguagePair) {
                pausedSession = data.pausedSession;
                document.getElementById('continue-session-btn').classList.remove('hidden');
                document.getElementById('remaining-words').textContent = 
                    pausedSession.cards.length - pausedSession.currentIndex;
            } else {
                document.getElementById('continue-session-btn').classList.add('hidden');
                pausedSession = null;
            }
        }

        function startSession(size) {
            devLog(`Starting session with size: ${size}`, 'info');
            
            const data = loadProgress();
            const now = Date.now();
            currentSession = [];
            
            const vocabSet = vocabularyData[currentLanguagePair] || [];
            const newCards = [];
            const reviewCards = [];
            
            vocabSet.forEach(card => {
                const cardProgress = data.progress?.[currentLanguagePair]?.[card.id];
                if (!cardProgress) {
                    newCards.push({...card, type: 'new'});
                } else if (cardProgress.nextReview <= now) {
                    reviewCards.push({...card, type: 'review'});
                }
            });
            
            devLog(`Available: ${newCards.length} new, ${reviewCards.length} review cards`, 'info');
            
            let targetNew = 0;
            let targetReview = 0;
            
            const completedNew = data.dailyProgress?.new || 0;
            const completedReview = data.dailyProgress?.review || 0;
            
            if (size === 0) {
                targetNew = Math.max(0, dailyGoal.new - completedNew);
                targetReview = Math.max(0, dailyGoal.review - completedReview);
            } else {
                let remainingSize = size;
                
                const reviewsNeeded = Math.max(0, dailyGoal.review - completedReview);
                targetReview = Math.min(remainingSize, reviewCards.length, reviewsNeeded);
                remainingSize -= targetReview;
                
                if (remainingSize > 0) {
                    const newNeeded = Math.max(0, dailyGoal.new - completedNew);
                    targetNew = Math.min(remainingSize, newCards.length, newNeeded);
                }
                
                if (targetNew + targetReview < size && completedNew >= dailyGoal.new && completedReview >= dailyGoal.review) {
                    const extraReviews = Math.min(size - targetNew - targetReview, reviewCards.length - targetReview);
                    targetReview += extraReviews;
                }
                
                if (targetNew + targetReview < size) {
                    const extraNew = Math.min(size - targetNew - targetReview, newCards.length - targetNew);
                    targetNew += extraNew;
                }
            }
            
            currentSession = [
                ...reviewCards.slice(0, targetReview),
                ...newCards.slice(0, targetNew)
            ];
            
            if (currentSession.length === 0) {
                const feedback = `
                    <div class="no-cards">
                        <h2>No Cards Available</h2>
                        <p style="margin: 20px 0;">
                            ${reviewCards.length === 0 && newCards.length === 0 ? 
                                'All cards are scheduled for future review. Great job! Come back tomorrow.' :
                                'You\'ve completed your daily goals! Come back tomorrow for more practice.'}
                        </p>
                        <p style="color: #666; font-size: 14px;">
                            Next review: Tomorrow<br>
                            Cards mastered: ${document.getElementById('total-learned').textContent}
                        </p>
                        <button class="btn-primary" onclick="backToStart()">Back to Home</button>
                    </div>
                `;
                document.getElementById('complete-screen').innerHTML = feedback;
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('complete-screen').classList.remove('hidden');
                return;
            }
            
            // Shuffle session
            currentSession.sort(() => Math.random() - 0.5);
            devLog(`Starting session with ${currentSession.length} cards`, 'success');
            
            // Initialize session
            sessionStats = {
                correct: 0,
                total: 0,
                startTime: Date.now(),
                wordsCompleted: []
            };
            currentCardIndex = 0;
            
            // Clear paused session
            pausedSession = null;
            const saveData = loadProgress();
            delete saveData.pausedSession;
            saveProgress(saveData);
            
            // Switch to study mode UI
            document.getElementById('main-container').classList.add('study-mode');
            document.getElementById('home-content').style.display = 'none';
            
            // Show study screen
            document.getElementById('study-screen').classList.remove('hidden');
            document.getElementById('study-screen').style.display = 'flex';
            
            // Re-setup long-press for study screen skill pills
            setupSkillPillLongPress();
            
            showCard();
        }

        function continueSession() {
            if (!pausedSession) return;
            
            currentSession = pausedSession.cards;
            currentCardIndex = pausedSession.currentIndex;
            sessionStats = pausedSession.stats;
            
            // Clear paused session from storage
            const data = loadProgress();
            delete data.pausedSession;
            saveProgress(data);
            pausedSession = null;
            
            // Switch to study mode UI
            document.getElementById('main-container').classList.add('study-mode');
            document.getElementById('home-content').style.display = 'none';
            
            // Show study screen
            document.getElementById('study-screen').classList.remove('hidden');
            document.getElementById('study-screen').style.display = 'flex';
            
            // Re-setup long-press for study screen skill pills
            setupSkillPillLongPress();
            
            showCard();
        }

        function pauseSession() {
            const data = loadProgress();
            
            // Save session state
            data.pausedSession = {
                cards: currentSession,
                currentIndex: currentCardIndex,
                stats: sessionStats,
                languagePair: currentLanguagePair
            };
            
            // Update time spent
            if (sessionStats.startTime) {
                const timeSpent = (Date.now() - sessionStats.startTime) / 60000;
                data.dailyProgress.timeSpent = (data.dailyProgress.timeSpent || 0) + timeSpent;
            }
            
            saveProgress(data);
            
            // Return to home
            backToStart();
        }

        function showCard(preserveSkillLevel = false) {
            if (currentCardIndex >= currentSession.length) {
                completeSession();
                return;
            }
            
            const card = currentSession[currentCardIndex];
            
            // Only determine skill level if not preserving (i.e., not switching manually)
            if (!preserveSkillLevel) {
                currentCardSkillLevel = determineCardSkillLevel(card.id);
            }
            devLog(`Showing card ${card.id} at ${SKILL_NAMES[currentCardSkillLevel]} level`, 'info');
            
            // Update skill display
            updateCardSkillDisplay(card.id);
            
            // Reset UI
            document.getElementById('word').textContent = card.word;
            document.getElementById('category').textContent = card.category;
            document.getElementById('feedback').classList.add('hidden');
            isAnswerShown = false;
            selectedChoiceIndex = -1;
            
            // Hide romanization initially
            const romanizationEl = document.getElementById('romanization');
            if (card.romanization) {
                romanizationEl.textContent = card.romanization;
                romanizationEl.classList.add('hidden');
            } else {
                romanizationEl.classList.add('hidden');
            }
            
            // Show appropriate input method based on skill level
            const choiceGrid = document.getElementById('choice-grid');
            const inputGroup = document.getElementById('input-group');
            
            if (currentCardSkillLevel === SKILL_LEVELS.BEGINNER) {
                // Multiple choice
                choiceGrid.classList.remove('hidden');
                inputGroup.classList.add('hidden');
                
                const vocabSet = vocabularyData[currentLanguagePair] || [];
                const options = generateMultipleChoice(card, vocabSet);
                renderMultipleChoice(options);
            } else {
                // Text input for intermediate and advanced
                choiceGrid.classList.add('hidden');
                inputGroup.classList.remove('hidden');
                document.getElementById('answer').value = '';
                document.getElementById('answer').focus();
                
                // Update placeholder based on level
                const placeholder = currentCardSkillLevel === SKILL_LEVELS.INTERMEDIATE ?
                    'Type the translation (diacritics optional)...' :
                    'Type the exact translation...';
                document.getElementById('answer').placeholder = placeholder;
            }
            
            // Update progress display
            document.getElementById('current-word-num').textContent = currentCardIndex + 1;
            document.getElementById('total-words').textContent = currentSession.length;
            
            // Reset button
            const button = document.getElementById('action-button');
            button.textContent = 'Check Answer';
            button.classList.remove('next');
            
            updateSessionProgress();
        }

        function checkAnswer() {
            if (isAnswerShown) {
                nextCard();
                return;
            }
            
            const card = currentSession[currentCardIndex];
            let isCorrect = false;
            let feedbackMessage = '';
            let feedbackClass = '';
            
            if (currentCardSkillLevel === SKILL_LEVELS.BEGINNER) {
                // Multiple choice
                if (selectedChoiceIndex === -1) {
                    devLog('No choice selected', 'error');
                    return;
                }
                
                const choices = document.querySelectorAll('.choice-btn');
                const selectedBtn = choices[selectedChoiceIndex];
                isCorrect = selectedBtn.dataset.correct === 'true';
                
                // Visual feedback
                choices.forEach(btn => {
                    if (btn.dataset.correct === 'true') {
                        btn.classList.add('correct');
                    } else if (btn === selectedBtn && !isCorrect) {
                        btn.classList.add('incorrect');
                    } else {
                        btn.classList.add('dimmed');
                    }
                    btn.disabled = true;
                });
                
                feedbackMessage = isCorrect ? '✓ Correct!' : `✗ Incorrect. The answer is: <strong>${card.translation}</strong>`;
                feedbackClass = isCorrect ? 'correct' : 'incorrect';
                
            } else if (currentCardSkillLevel === SKILL_LEVELS.INTERMEDIATE) {
                // Flexible typing
                const userAnswer = document.getElementById('answer').value.trim();
                const correctAnswer = card.translation;
                
                // Check if it's close enough (without diacritics)
                const isCloseEnough = checkIntermediateAnswer(userAnswer, correctAnswer);
                
                // Check if it's exactly correct
                const isExact = userAnswer.toLowerCase() === correctAnswer.toLowerCase();
                
                if (isExact) {
                    feedbackMessage = '✓ Perfect!';
                    feedbackClass = 'correct';
                    isCorrect = true;
                } else if (isCloseEnough) {
                    feedbackMessage = `✓ Close enough!`;
                    feedbackMessage += `<div class="user-answer">You typed: ${userAnswer}</div>`;
                    feedbackMessage += `<div class="correct-spelling">Exact spelling: <strong>${correctAnswer}</strong></div>`;
                    feedbackClass = 'partial';
                    isCorrect = true; // Count as correct for progression
                } else {
                    feedbackMessage = `✗ Incorrect.`;
                    feedbackMessage += `<div class="user-answer">You typed: ${userAnswer}</div>`;
                    feedbackMessage += `<div class="correct-spelling">Correct answer: <strong>${correctAnswer}</strong></div>`;
                    feedbackClass = 'incorrect';
                    isCorrect = false;
                }
                
            } else {
                // Advanced - exact match
                const userAnswer = document.getElementById('answer').value.trim().toLowerCase();
                const correctAnswer = card.translation.toLowerCase();
                
                isCorrect = userAnswer === correctAnswer || 
                          userAnswer === correctAnswer.replace(/\s+/g, '');
                
                feedbackMessage = isCorrect ? '✓ Perfect!' : `✗ Incorrect. The answer is: <strong>${card.translation}</strong>`;
                feedbackClass = isCorrect ? 'correct' : 'incorrect';
            }
            
            // Show romanization when answer is checked
            const romanizationEl = document.getElementById('romanization');
            if (card.romanization) {
                romanizationEl.classList.remove('hidden');
            }
            
            // Show feedback
            const feedback = document.getElementById('feedback');
            feedback.classList.remove('hidden');
            feedback.className = `feedback ${feedbackClass}`;
            feedback.innerHTML = feedbackMessage;
            
            // Update progress
            updateCardProgressWithSkillLevel(card.id, isCorrect, currentCardSkillLevel, card.type);
            
            if (isCorrect) {
                sessionStats.correct++;
            }
            sessionStats.total++;
            sessionStats.wordsCompleted.push(card.id);
            
            isAnswerShown = true;
            
            // Change button to "Next Card"
            const button = document.getElementById('action-button');
            button.textContent = currentCardIndex === currentSession.length - 1 ? 'Finish' : 'Next Card';
            button.classList.add('next');
            
            updateSessionProgress();
        }

        function nextCard() {
            currentCardIndex++;
            showCard();
        }

        function updateCardProgressWithSkillLevel(cardId, isCorrect, skillLevel, cardType) {
            const data = loadProgress();
            
            devLog(`Updating card ${cardId}: ${isCorrect ? 'CORRECT' : 'INCORRECT'} at ${SKILL_NAMES[skillLevel]} level (${cardType})`, isCorrect ? 'success' : 'error');
            
            if (!data.progress) data.progress = {};
            if (!data.progress[currentLanguagePair]) data.progress[currentLanguagePair] = {};
            
            let cardProgress = data.progress[currentLanguagePair][cardId];
            const isNewCard = !cardProgress;
            
            if (!cardProgress) {
                // Initialize new card
                cardProgress = {
                    level: 0,
                    lastSeen: Date.now(),
                    timesCorrect: 0,
                    timesSeen: 0,
                    skillLevel: skillLevel,
                    skillProgress: {
                        1: { correct: 0, total: 0, streak: 0 },
                        2: { correct: 0, total: 0, streak: 0 },
                        3: { correct: 0, total: 0, streak: 0 }
                    },
                    recommendedSkillLevel: 1
                };
            }
            
            // Update skill-specific statistics
            if (!cardProgress.skillProgress) {
                cardProgress.skillProgress = {
                    1: { correct: 0, total: 0, streak: 0 },
                    2: { correct: 0, total: 0, streak: 0 },
                    3: { correct: 0, total: 0, streak: 0 }
                };
            }
            
            const skillStats = cardProgress.skillProgress[skillLevel];
            skillStats.total++;
            
            if (isCorrect) {
                skillStats.correct++;
                skillStats.streak++;
                
                // Apply skill multiplier to level progression
                const multiplier = SKILL_MULTIPLIERS[skillLevel];
                cardProgress.level = Math.min(5, cardProgress.level + multiplier);
                cardProgress.timesCorrect++;
                
                devLog(`Card level increased by ${multiplier} to ${cardProgress.level}`, 'info');
            } else {
                skillStats.streak = 0;
                
                // Bigger penalty for failing at easier levels
                const penalty = skillLevel === SKILL_LEVELS.BEGINNER ? 0.5 : 1.0;
                cardProgress.level = Math.max(0, cardProgress.level - penalty);
                
                devLog(`Card level decreased by ${penalty} to ${cardProgress.level}`, 'info');
            }
            
            cardProgress.timesSeen++;
            cardProgress.lastSeen = Date.now();
            cardProgress.skillLevel = skillLevel;
            
            // Calculate next review time based on fractional level
            const effectiveLevel = Math.floor(cardProgress.level);
            const fraction = cardProgress.level - effectiveLevel;
            
            let daysUntilNext;
            if (effectiveLevel >= BASE_INTERVALS.length - 1) {
                daysUntilNext = BASE_INTERVALS[BASE_INTERVALS.length - 1];
            } else {
                const lowerDays = BASE_INTERVALS[effectiveLevel];
                const upperDays = BASE_INTERVALS[effectiveLevel + 1];
                daysUntilNext = lowerDays + (upperDays - lowerDays) * fraction;
            }
            
            cardProgress.nextReview = Date.now() + (daysUntilNext * 86400000);
            
            devLog(`Next review in ${Math.round(daysUntilNext)} days`, 'info');
            
            // Check for skill level promotion
            if (skillStats.streak >= PROMOTION_THRESHOLD.streak && 
                skillStats.total >= 3 &&
                (skillStats.correct / skillStats.total) >= PROMOTION_THRESHOLD.accuracy &&
                skillLevel < 3) {
                cardProgress.recommendedSkillLevel = skillLevel + 1;
                devLog(`Card ${cardId} ready for promotion to ${SKILL_NAMES[skillLevel + 1]}!`, 'success');
            }
            
            data.progress[currentLanguagePair][cardId] = cardProgress;
            
            // Update daily progress
            if (!data.dailyProgress) {
                data.dailyProgress = { new: 0, review: 0, sessions: [], timeSpent: 0, cardsSeen: {} };
            }
            
            // Track if this card was already counted in today's progress
            const cardSeenToday = data.dailyProgress.cardsSeen[cardId];
            
            if (!cardSeenToday) {
                // First time seeing this card today
                data.dailyProgress.cardsSeen[cardId] = true;
                
                if (isNewCard || cardType === 'new') {
                    // This is a new card
                    data.dailyProgress.new = Math.min(dailyGoal.new + 10, (data.dailyProgress.new || 0) + 1);
                    devLog(`Daily new words: ${data.dailyProgress.new}/${dailyGoal.new}`, 'info');
                    
                    // Count as learned if mastered at advanced level
                    if (isCorrect && skillLevel === SKILL_LEVELS.ADVANCED) {
                        data.totalLearned = (data.totalLearned || 0) + 1;
                    }
                } else {
                    // This is a review card
                    data.dailyProgress.review = Math.min(dailyGoal.review + 10, (data.dailyProgress.review || 0) + 1);
                    devLog(`Daily review words: ${data.dailyProgress.review}/${dailyGoal.review}`, 'info');
                }
            }
            
            // Update overall accuracy
            if (!data.accuracy) data.accuracy = { correct: 0, total: 0 };
            data.accuracy.total++;
            if (isCorrect) data.accuracy.correct++;
            
            saveProgress(data);
            updateDailyGoal();
            updateStats();
        }

        function completeSession() {
            const data = loadProgress();
            
            // Calculate session time
            const sessionTime = sessionStats.startTime ? 
                Math.round((Date.now() - sessionStats.startTime) / 60000) : 0;
            
            // Update time spent
            data.dailyProgress.timeSpent = (data.dailyProgress.timeSpent || 0) + sessionTime;
            
            // Add to session history
            if (!data.dailyProgress.sessions) data.dailyProgress.sessions = [];
            data.dailyProgress.sessions.push({
                time: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                words: sessionStats.total,
                accuracy: sessionStats.total > 0 ? Math.round((sessionStats.correct / sessionStats.total) * 100) : 0
            });
            
            // Adaptive goal adjustment
            adjustDailyGoal(data);
            
            saveProgress(data);
            showCompleteScreen();
        }

        function adjustDailyGoal(data) {
            const dailyProgress = data.dailyProgress;
            const sessions = dailyProgress.sessions || [];
            
            // Only adjust after completing at least 2 sessions
            if (sessions.length < 2) return;
            
            // Calculate average accuracy for today
            const todayAccuracy = sessions.reduce((acc, s) => acc + s.accuracy, 0) / sessions.length;
            
            // Adjust goals for tomorrow
            if (todayAccuracy > 85 && dailyProgress.new >= dailyGoal.new && dailyProgress.review >= dailyGoal.review) {
                // Increase slightly if doing well and completing goals
                dailyGoal.new = Math.min(10, dailyGoal.new + 1);
                dailyGoal.review = Math.min(15, dailyGoal.review + 1);
                devLog('Daily goals increased due to excellent performance!', 'success');
            } else if (todayAccuracy < 60) {
                // Decrease if struggling
                dailyGoal.new = Math.max(2, dailyGoal.new - 1);
                dailyGoal.review = Math.max(3, dailyGoal.review - 1);
                devLog('Daily goals decreased to reduce pressure', 'info');
            }
            
            // Save adjusted goals
            data.adaptiveGoal = dailyGoal;
        }

        function showCompleteScreen() {
            const data = loadProgress();
            const totalGoal = dailyGoal.new + dailyGoal.review;
            const totalComplete = (data.dailyProgress?.new || 0) + (data.dailyProgress?.review || 0);
            
            // Hide study screen
            document.getElementById('study-screen').classList.add('hidden');
            document.getElementById('study-screen').style.display = 'none';
            
            // Hide home content
            document.getElementById('home-content').style.display = 'none';
            
            // Rebuild complete screen HTML to ensure all elements exist
            const completeScreen = document.getElementById('complete-screen');
            completeScreen.innerHTML = `
                <div id="achievement" class="achievement ${totalComplete >= totalGoal ? '' : 'hidden'}">
                    <div class="achievement-title">🎉 Goal Achieved!</div>
                    <div class="achievement-desc">You've completed your daily goal!</div>
                </div>
                
                <div class="no-cards">
                    <h2>Session Complete!</h2>
                    <p style="margin: 20px 0;">
                        Words practiced: <strong>${sessionStats.total}</strong><br>
                        Accuracy: <strong>${sessionStats.total > 0 ? Math.round((sessionStats.correct / sessionStats.total) * 100) : 0}%</strong><br>
                        Time: <strong>${sessionStats.startTime ? Math.round((Date.now() - sessionStats.startTime) / 60000) : 0}</strong> minutes
                    </p>
                    <button class="btn-primary" onclick="backToStart()">Continue Learning</button>
                    <button class="btn-secondary" onclick="finishForToday()" style="margin-top: 10px;">Finish for Now</button>
                </div>
            `;
            
            // Show complete screen
            completeScreen.classList.remove('hidden');
            completeScreen.style.display = 'block';
            
            // Remove study mode
            document.getElementById('main-container').classList.remove('study-mode');
            
            updateStats();
        }

        function updateSessionHistory() {
            const data = loadProgress();
            const sessions = data.dailyProgress?.sessions || [];
            const historyDiv = document.getElementById('session-history');
            
            if (sessions.length === 0) {
                historyDiv.innerHTML = '<div style="color: #999; font-size: 13px;">No sessions yet today</div>';
                return;
            }
            
            historyDiv.innerHTML = sessions.map(s => `
                <div class="history-item">
                    <span>${s.time}</span>
                    <span>${s.words} words • ${s.accuracy}%</span>
                </div>
            `).join('');
        }

        function backToStart() {
            document.getElementById('study-screen').classList.add('hidden');
            document.getElementById('study-screen').style.display = 'none';
            document.getElementById('complete-screen').classList.add('hidden');
            document.getElementById('complete-screen').style.display = 'none';
            
            // Restore normal UI
            document.getElementById('main-container').classList.remove('study-mode');
            document.getElementById('home-content').style.display = 'block';
            
            updateDailyGoal();
            updateStats();
            checkPausedSession();
            updateSessionHistory();
        }

        function finishForToday() {
            backToStart();
        }

        // Initialize when page loads
        window.onload = function() {
            // Force hide study and complete screens on load
            const studyScreen = document.getElementById('study-screen');
            const completeScreen = document.getElementById('complete-screen');
            const homeContent = document.getElementById('home-content');
            
            if (studyScreen) {
                studyScreen.classList.add('hidden');
                studyScreen.style.display = 'none';
            }
            if (completeScreen) {
                completeScreen.classList.add('hidden');
                completeScreen.style.display = 'none';
            }
            if (homeContent) {
                homeContent.style.display = 'block';
            }
            
            // Remove study mode from container
            document.getElementById('main-container').classList.remove('study-mode');
            
            initApp();
        };
    </script>
</body>
</html>